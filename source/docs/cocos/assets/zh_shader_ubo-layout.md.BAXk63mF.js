import{_ as s,c as i,o as a,a4 as n}from"./chunks/framework.uQk9_EO2.js";const E=JSON.parse('{"title":"UBO 内存布局策略","description":"","frontmatter":{},"headers":[],"relativePath":"zh/shader/ubo-layout.md","filePath":"zh/shader/ubo-layout.md","lastUpdated":1712305443000}'),e={name:"zh/shader/ubo-layout.md"},l=n(`<h1 id="ubo-内存布局策略" tabindex="-1">UBO 内存布局策略 <a class="header-anchor" href="#ubo-内存布局策略" aria-label="Permalink to &quot;UBO 内存布局策略&quot;">​</a></h1><p>Cocos Shader 规定，所有非 sampler 类型的 uniform 都应以 UBO（Uniform Buffer Object/Uniform Block）形式声明。</p><p>以内置着色器 <code>builtin-standard.effect</code> 为例，其 uniform block 声明如下：</p><div class="language-glsl vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">glsl</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">uniform</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Constants {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    vec4 tilingOffset;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    vec4 albedo;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    vec4 albedoScaleAndCutoff;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    vec4 pbrParams;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    vec4 miscParams;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    vec4 emissive;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    vec4 emissiveScaleParam;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  };</span></span></code></pre></div><p>并且所有的 UBO 应当遵守以下规则：</p><ol><li>不应出现 vec3 成员；</li><li>对数组类型成员，每个元素 size 不能小于 vec4；</li><li>不允许任何会引入 padding 的成员声明顺序。</li></ol><p>Cocos Shader 在编译时会对上述规则进行检查，以便在导入错误（implicit padding 相关）时及时提醒修改。</p><p>这可能听起来有些过分严格，但背后有非常务实的考量：<br> 首先，UBO 是渲染管线内要做到高效数据复用的唯一基本单位，离散声明已不是一个选项；<br> 其次，WebGL2 的 UBO 只支持 std140 布局，它遵守一套比较原始的 padding 规则[^1]：</p><ul><li><p>所有 vec3 成员都会补齐至 vec4：</p><div class="language-glsl vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">glsl</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">uniform</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ControversialType {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  vec3 v3_1;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // offset 0, length 16 [IMPLICIT PADDING!]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // total of 16 bytes</span></span></code></pre></div></li><li><p>任意长度小于 vec4 类型的数组和结构体，都会将元素补齐至 vec4：</p><div class="language-glsl vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">glsl</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">uniform</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ProblematicArrays {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  float</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> f4_1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">];</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // offset 0, stride 16, length 64 [IMPLICIT PADDING!]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // total of 64 bytes</span></span></code></pre></div></li><li><p>所有成员在 UBO 内的实际偏移都会按自身所占字节数对齐[^2]：</p><div class="language-glsl vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">glsl</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">uniform</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> IncorrectUBOOrder {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  float</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> f1_1;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // offset 0, length 4 (aligned to 4 bytes)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  vec2 v2;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // offset 8, length 8 (aligned to 8 bytes) [IMPLICIT PADDING!]</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  float</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> f1_2;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // offset 16, length 4 (aligned to 4 bytes)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // total of 32 bytes</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">uniform</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> CorrectUBOOrder {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  float</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> f1_1;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // offset 0, length 4 (aligned to 4 bytes)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  float</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> f1_2;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // offset 4, length 4 (aligned to 4 bytes)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  vec2 v2;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // offset 8, length 8 (aligned to 8 bytes)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // total of 16 bytes</span></span></code></pre></div></li></ul><p>这意味着大量的空间浪费，且某些设备的驱动实现也并不完全符合此标准[^3]，因此目前 Cocos Shader 选择限制这部分功能的使用，以帮助排除一部分非常隐晦的运行时问题。</p><blockquote><p><strong>再次提醒：uniform 的类型与 inspector 的显示和运行时参数赋值时的程序接口可以不直接对应，通过 <a href="./pass-parameter-list#Properties">property target</a> 机制，可以独立编辑任意 uniform 的具体分量。</strong></p></blockquote><p>[^1]: <a href="http://www.opengl.org/registry/doc/glspec45.core.pdf#page=159" target="_blank" rel="noreferrer">OpenGL 4.5, Section 7.6.2.2, page 137</a></p><p>[^2]: 注意在示例代码中，UBO IncorrectUBOOrder 的总长度为 32 字节，实际上这个数据到今天也依然是平台相关的，看起来是由于 GLSL 标准的疏忽，更多相关讨论可以参考 <a href="https://bugs.chromium.org/p/chromium/issues/detail?id=988988" target="_blank" rel="noreferrer">这里</a>。</p><p>[^3]: <strong>Interface Block - OpenGL Wiki</strong>：<a href="https://www.khronos.org/opengl/wiki/Interface_Block_(GLSL)#Memory_layout" target="_blank" rel="noreferrer">https://www.khronos.org/opengl/wiki/Interface_Block_(GLSL)#Memory_layout</a></p>`,14),t=[l];function p(h,k,r,o,d,c){return a(),i("div",null,t)}const y=s(e,[["render",p]]);export{E as __pageData,y as default};
