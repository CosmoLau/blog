import{_ as s,c as i,o as e,a4 as a}from"./chunks/framework.uQk9_EO2.js";const t="/docs/cocos/assets/import-menu.Bj_uqwKy.png",n="/docs/cocos/assets/import-select-project.ozcDkhdq.png",l="/docs/cocos/assets/import-panel.BPhsZ1cy.png",o="/docs/cocos/assets/build-panel.M0pRARTi.png",p="/docs/cocos/assets/build.CNsOMO6Q.png",r="/docs/cocos/assets/preview.DGOdC2Tw.png",c="/docs/cocos/assets/animation.DvPQv2P4.png",d="/docs/cocos/assets/project-setting.CGRtOyXU.png",h="/docs/cocos/assets/texture-compress-setting.BOk1BJqB.png",k="/docs/cocos/assets/extension-plugin.D32Yhnvt.png",g="/docs/cocos/assets/web-v243.CVyAm5pR.png",E="/docs/cocos/assets/web-v3.DwYOejNY.png",y="/docs/cocos/assets/web-cocosjs.BEo1KMIU.png",u="/docs/cocos/assets/wechat-v243.jpUBAg7A.png",C="/docs/cocos/assets/wechat-v3.Bszp5nHP.png",m="/docs/cocos/assets/wechat-cocosjs.B7n-sqdR.png",F="/docs/cocos/assets/v243-windows.BzG2JrtI.png",A="/docs/cocos/assets/v3-windows.B3p8xYD9.png",v="/docs/cocos/assets/engine-common.B6mOaxYy.png",b="/docs/cocos/assets/v3-assets.CdoakdWd.png",D="/docs/cocos/assets/v243-build-template.B7cUrUD0.png",x="/docs/cocos/assets/v3-build-template.CavPej-A.png",f="/docs/cocos/assets/v3-build-native.Bz1aVXTH.png",_="/docs/cocos/assets/update-setting.Frhxng6Q.png",G=JSON.parse('{"title":"Cocos Creator 3.0 升级指南","description":"","frontmatter":{},"headers":[],"relativePath":"zh/release-notes/upgrade-guide-v3.0.md","filePath":"zh/release-notes/upgrade-guide-v3.0.md","lastUpdated":1712305443000}'),B={name:"zh/release-notes/upgrade-guide-v3.0.md"},q=a('<h1 id="cocos-creator-3-0-升级指南" tabindex="-1">Cocos Creator 3.0 升级指南 <a class="header-anchor" href="#cocos-creator-3-0-升级指南" aria-label="Permalink to &quot;Cocos Creator 3.0 升级指南&quot;">​</a></h1><h2 id="版本介绍" tabindex="-1">版本介绍 <a class="header-anchor" href="#版本介绍" aria-label="Permalink to &quot;版本介绍&quot;">​</a></h2><p>Cocos Creator 3.0 集成了原有 2D 和 3D 两套产品的所有功能，带来了诸多重大更新，将做为 Creator 之后的主力版本。同时 v3.0 还延续了 Cocos 在 2D 品类上轻量高效的优势，并且为 3D 重度游戏提供高效的开发体验。</p><ul><li><p><strong>对于 Cocos Creator 2.x</strong></p><p>为了保障现有的 v2.4 项目平稳过渡，我们会将 v2.4 做为 LTS（长期支持）版本，提供后续 <strong>两年</strong> 的持续更新！在 <strong>2021</strong> 年，v2.4 将继续更新版本，提供缺陷修复和新的 Cocos Creator 小游戏平台支持，保障大家的项目成功上线。在 <strong>2022</strong> 年我们还将为开发者持续提供 v2.4 的关键问题修复，保障已上线的游戏平稳运营！因此：</p><ul><li><p><strong>现有的 v2.x 项目可以安心继续开发，无需强制升级到 v3.0</strong>。</p></li><li><p><strong>新项目建议使用 v3.0 版本开发</strong>，我们会不断优化 v3.0 的开发体验和运行效率，支撑好 2D、3D 等不同品类的重度游戏顺利上线。</p></li></ul></li><li><p><strong>对于 Cocos Creator 3D</strong></p><p>原有的 Cocos Creator 3D 做为 Creator 的分支版本，已经面向中国进行了长达一年的迭代，成功上线了 <strong>星空大决战</strong>、<strong>最强魔斗士</strong> 等重度项目！Cocos Creator 3.0 发布后，Cocos Creator 3D 也将包含在 v3.0 中，现有的 v1.2 项目都可直接升级，因此 Cocos Creator 3D 后续不会再发布独立版本。</p></li></ul><p>Cocos Creator 3.0 使用了面向未来的全新引擎架构，将为引擎带来高性能、面向数据以及负载均衡的渲染器，并且无缝支持 Vulkan &amp; Metal 多后端渲染，未来还会支持移动端 VR/AR 及部分主机平台。</p><p>关于 Cocos Creator 3.0 的详细介绍，请移步 <a href="https://cocos.com/creator" target="_blank" rel="noreferrer">官网更新说明</a>。</p><h2 id="如何迁移-cocos-creator-2-x-项目" tabindex="-1">如何迁移 Cocos Creator 2.x 项目 <a class="header-anchor" href="#如何迁移-cocos-creator-2-x-项目" aria-label="Permalink to &quot;如何迁移 Cocos Creator 2.x 项目&quot;">​</a></h2><p>虽然 <strong>我们不建议开发中的项目，特别是即将上线的项目强升 v3.0</strong>，但是我们仍在 Cocos Creator 3.0 推出了 v2.x 资源导入工具。此工具支持旧项目资源完美导入，以及代码的辅助迁移。</p><h3 id="资源导入" tabindex="-1">资源导入 <a class="header-anchor" href="#资源导入" aria-label="Permalink to &quot;资源导入&quot;">​</a></h3><p>开发者只需要点击主菜单中的 <strong>文件 -&gt; 导入 Cocos Creator 2.x 项目</strong>。</p><p><img src="'+t+'" alt="import-menu"></p><p>然后在弹出的文件浏览对话框中选择 v2.x 项目的根目录。</p><p><img src="'+n+'" alt="import-select-project"></p><blockquote><p><strong>注意</strong>：旧项目推荐先升级到 v2.4.3 或以上版本，然后再导入到 v3.0，否则无法确保导入结果的正确性。</p></blockquote><p>v2.x 项目中所有的资源便会自动呈现在弹出的 <strong>导入 Cocos Creator 2.x 项目</strong> 面板中，开发者可以再次确认要导入的资源，然后点击面板右下角的 <strong>导入</strong> 按钮完成导入。若开发者想要切换导入的 v2.x 项目，点击下图中的搜索图标按钮，即可重新选择项目。</p><p><img src="'+l+`" alt="import-project"></p><p>面板左下角的 <strong>使用说明</strong> 按钮可跳转到导入项目插件的 GitHub 仓库，用于 <a href="https://github.com/cocos-creator/plugin-import-2.x/blob/main/README.md" target="_blank" rel="noreferrer">更新导入插件</a> 或者提交反馈。</p><h3 id="代码迁移" tabindex="-1">代码迁移 <a class="header-anchor" href="#代码迁移" aria-label="Permalink to &quot;代码迁移&quot;">​</a></h3><p>当导入使用 JavaScript 进行开发的 v2.x 项目时，导入插件的代码辅助迁移功能会先将 JavaScript 转换成 TypeScript，再进行代码迁移。</p><p>例如，导入的 v2.x 项目 JavaScript 代码如下：</p><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// AudioController.js</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">cc.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Class</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    extends: cc.Component,</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    properties: {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        audioSource: {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            type: cc.AudioSource,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            default: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">null</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    },</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    play</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.audioSource.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">play</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    },</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    pause</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.audioSource.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">pause</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    },</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre></div><p>由于各个项目代码的写法差异以及不同的复杂程度，目前导入插件对代码的迁移仅添加 <strong>组件类型声明</strong>、<strong>属性声明</strong> 和 <strong>函数声明</strong>，组件在场景中的引用都会得到 <strong>保留</strong>，并且函数内部的代码会以 <strong>注释</strong> 的形式迁移。<br> 另外，v2.x 的原代码则会以注释的形式完整保留一份在迁移后代码的末尾，方便开发者手动转换时参考。</p><p>上述示例代码在经过导入插件的代码辅助迁移之后，结果如下所示：</p><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// AudioController.ts</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { _decorator, Component, AudioSource } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;cc&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">ccclass</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">property</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> _decorator;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ccclass</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;AudioController&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> AudioController</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> extends</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Component</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    @property</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> audioSource</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">AudioSource</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;null&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    play</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        //this.audioSource.play();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    pause</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        //this.audioSource.pause();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/**</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> * 注意：已把原脚本注释，由于脚本变动过大，转换的时候可能有遗落，需要自行手动转换</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> */</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// cc.Class({</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//     extends: cc.Component,</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//     properties: {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//         audioSource: {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//             type: cc.AudioSource,</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//             default: null</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//         },</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//     },</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//     play: function () {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//         this.audioSource.play();</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//     },</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//     pause: function () {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//         this.audioSource.pause();</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//     },</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// });</span></span></code></pre></div><blockquote><p><strong>注意</strong>：</p><ol><li>如果是从 JavaScript 转换为 TypeScript 的。需要在 TypeScript 中声明 <strong>所有属性</strong> 并设置默认值。</li><li>如果 <strong>属性检查器</strong> 面板数据丢失，则需要检查属性类型是否与 v2.x 相同。</li><li>如果 JavaScript 代码使用外部类型，TypeScript 会提示：通过导入外部源文件或声明进行修复。</li></ol></blockquote><h2 id="旧版本开发者快速上手" tabindex="-1">旧版本开发者快速上手 <a class="header-anchor" href="#旧版本开发者快速上手" aria-label="Permalink to &quot;旧版本开发者快速上手&quot;">​</a></h2><h3 id="材质升级" tabindex="-1">材质升级 <a class="header-anchor" href="#材质升级" aria-label="Permalink to &quot;材质升级&quot;">​</a></h3><p>在 v3.0 中我们持续改进了材质系统的设计和内置 Shader API，所以从 v2.x 升级到 v3.x 时，部分内容无法自动升级，还需要开发者手动进行调整，详情请参考 <a href="./../material-system/effect-2.x-to-3.0">材质升级指南</a>。</p><h3 id="引擎-api-升级" tabindex="-1">引擎 API 升级 <a class="header-anchor" href="#引擎-api-升级" aria-label="Permalink to &quot;引擎 API 升级&quot;">​</a></h3><h4 id="针对-cocos-creator-3d-1-2-用户" tabindex="-1">针对 Cocos Creator 3D 1.2 用户 <a class="header-anchor" href="#针对-cocos-creator-3d-1-2-用户" aria-label="Permalink to &quot;针对 Cocos Creator 3D 1.2 用户&quot;">​</a></h4><ol><li><p>Cocos Creator 3.0 资源加载相关的 API 与 v2.4 一致，都对 <code>loader</code> 进行了重构，v1.2 用户可参考 <a href="https://docs.cocos.com/creator/2.4/manual/zh/release-notes/asset-manager-upgrade-guide.html" target="_blank" rel="noreferrer">v2.4 资源管理模块升级指南</a> 进行升级。</p></li><li><p>组件类名更改</p><p>为了符合 v2.x 的 API 规范，Cocos Creator 3.0 将组件类名包含 Component 后缀这样的命名方式舍弃了，并做了数据的自动升级和代码的兼容。</p><p>不过建议开发者还是要在代码中搜索所有类似命名方式的使用，并尽快更改为无 Component 后缀的类名。可以使用下面正则表达式进行全局搜索（打开大小写敏感和正则匹配）：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>([A-Z]\\w+)Component</span></span></code></pre></div></li></ol><h4 id="针对-cocos-creator-2-x-用户" tabindex="-1">针对 Cocos Creator 2.x 用户 <a class="header-anchor" href="#针对-cocos-creator-2-x-用户" aria-label="Permalink to &quot;针对 Cocos Creator 2.x 用户&quot;">​</a></h4><ul><li><p>节点上 UI 相关接口变更如下：</p><ul><li><p>与坐标变换计算相关的接口（例如：<code>size</code> 和 <code>anchor</code>）变更如下：</p><p>需要先获取节点上的 <code>UITransform</code> 组件，再使用对应的接口，例如：</p><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> uiTrans</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> node.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getComponent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(UITransform)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">uiTrans.anchorX </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0.5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">uiTrans.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setContentSize</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(size);</span></span></code></pre></div></li><li><p>其余接口变更如下：</p><ul><li><p><code>color</code>：需要先获取节点上的渲染组件（例如：<code>Sprite</code> 组件），再使用对应的接口。</p></li><li><p><code>opacity</code>：如果节点上有渲染组件，直接设置渲染组件的 <code>color</code>。如果没有渲染组件，则可以通过添加 <code>UIOpacity</code> 组件，并设置相关属性。</p></li><li><p><code>skew</code>：该接口已被移除。</p></li><li><p><code>group</code>：变更为 <code>layer</code>。</p></li><li><p><code>zIndex</code>：变更为 <code>UITransform</code> 中的 <a href="./__APIDOC__/zh/class/UITransform">priority</a>。</p><blockquote><p><strong>注意</strong>：从 v3.1 开始，<code>priority</code> 属性已弃用，若需要调整节点树的顺序请使用 <code>setSiblingIndex</code> 方法。</p></blockquote></li></ul></li></ul></li><li><p><code>CCSpriteFrame</code>：</p><ul><li><p>移除接口：<code>copyWithZone</code>、<code>copy</code>、<code>clone</code> 和 <code>ensureLoadTexture</code>。</p></li><li><p>变更接口：</p><ul><li><p><code>setFlipX</code> 和 <code>isFlipX</code> -&gt; <code>flipUVX</code></p></li><li><p><code>setFlipY</code> 和 <code>isFlipY</code> -&gt; <code>flipUVY</code></p></li><li><p><code>getTexture</code> 和 <code>setTexture</code> -&gt; <code>texture</code>（此处的类型是 Texture2D/RenderTexture）。</p></li></ul></li><li><p>其余 <code>get</code> 和 <code>set</code> 对应的方法在 3.0 中都直接对应同名属性（例如：<code>getOffset</code> -&gt; <code>offset</code>）。</p></li></ul></li><li><p><code>CCTexture2D</code>：</p><ul><li><p>变更接口：<code>genMipmaps</code> -&gt; <code>mipmaps</code>、<code>initWithElement</code> -&gt; <code>image</code>。</p></li><li><p><code>initWithData</code> 整个方法被移除，类似的使用是将原先要传入的 <code>ArrayBufferView</code> 数据，传给新建的 <code>ImageAsset</code>，然后再用 <code>ImageAsset</code> 传给新建的 <code>Texture2D</code>，从而获得一份图片资源。</p></li></ul></li><li><p><code>cc.Action</code>：相关接口全部移除。</p></li><li><p><strong>物理</strong>：</p><ul><li><p>2D 变更组件：<code>cc.Collider</code> -&gt; <code>Collider2D</code>、<code>cc.BoxCollider</code> -&gt; <code>BoxCollider2D</code>、<code>cc.RigidBody</code> -&gt; <code>RigidBody2D</code> 等。</p></li><li><p>3D 变更组件：<code>cc.Collider3D</code> -&gt; <code>Collider</code>、<code>cc.BoxCollider3D</code> -&gt; <code>BoxCollider</code>、<code>cc.RigidBody3D</code> -&gt; <code>RigidBody</code> 等。</p></li></ul></li><li><p><strong>tween</strong>：</p><ul><li>变更接口：<code>cc.repeatForever</code> -&gt; <code>Tween.repeatForever</code>、<code>cc.reverseTime</code> -&gt; <code>Tween.reverseTime</code>、<code>cc.show</code> -&gt; <code>Tween.show</code> 等。</li></ul></li><li><p><strong>动画</strong>：</p><ul><li>变更接口：<code>addClip</code> -&gt; <code>createState</code>、<code>getClips</code> -&gt; <code>clips</code>、<code>playAdditive</code> -&gt; <code>crossFade</code>、<code>getAnimationState</code> -&gt; <code>getState</code> 等。</li></ul></li><li><p><strong>相机</strong>：</p><ul><li><p>移除接口：<code>findCamera</code>、<code>alignWithScreen</code>、<code>main</code>、<code>cameras</code>、 <code>zoomRatio</code> 和 <code>containsNode</code>。</p></li><li><p>变更接口：<code>backgroundColor</code> -&gt; <code>clearColor</code>、<code>cullingMask</code> -&gt; <code>visibility</code>、<code>depth</code> -&gt; <code>clearDepth</code>、<code>getScreenToWorldPoint</code> -&gt; <code>screenToWorld</code>、<code>getWorldToScreenPoint</code> -&gt; <code>worldToScreen</code>、<code>getRay</code> -&gt; <code>screenPointToRay</code> 等。</p></li></ul></li><li><p><strong>音频</strong>：</p><ul><li>变更接口：<code>getLoop</code> 和 <code>setLoop</code> -&gt; <code>loop</code>、<code>getVolume</code> 和 <code>setVolume</code> -&gt; <code>volume</code>、<code>getCurrentTime</code> 和 <code>setCurrentTime</code> -&gt; <code>currentTime</code>、<code>src</code> -&gt; <code>clip</code>。</li></ul></li><li><p><strong>材质</strong>：</p><ul><li><p>所有相关改动都需要获得 <strong>MeshRenderer</strong> 或其子类身上的 <strong>材质实例</strong> 来完成。</p></li><li><p>移除接口：<code>setBlend</code>、<code>setDepth</code>、<code>setStencilEnabled</code>、<code>setStencil</code>、<code>setCullMode</code> 和 <code>define</code>，其中除了 <code>define</code> 是调用 <code>recompileShaders</code> 完成更新，其余的都是调用 <code>overridePipelineStates</code> 完成更新。</p></li></ul></li><li><p><strong>sys</strong> 下的平台变量变更如下：</p></li></ul><table><thead><tr><th style="text-align:left;">Cocos Creator 2.x</th><th style="text-align:left;">Cocos Creator 3.0</th></tr></thead><tbody><tr><td style="text-align:left;"><code>BAIDU_GAME</code></td><td style="text-align:left;"><code>BAIDU_MINI_GAME</code></td></tr><tr><td style="text-align:left;"><code>VIVO_GAME</code></td><td style="text-align:left;"><code>VIVO_MINI_GAME</code></td></tr><tr><td style="text-align:left;"><code>OPPO_GAME</code></td><td style="text-align:left;"><code>OPPO_MINI_GAME</code></td></tr><tr><td style="text-align:left;"><code>HUAWEI_GAME</code></td><td style="text-align:left;"><code>HUAWEI_QUICK_GAME</code></td></tr><tr><td style="text-align:left;"><code>XIAOMI_GAME</code></td><td style="text-align:left;"><code>XIAOMI_QUICK_GAME</code></td></tr><tr><td style="text-align:left;"><code>JKW_GAME</code></td><td style="text-align:left;"><code>COCOSPLAY</code></td></tr><tr><td style="text-align:left;"><code>ALIPAY_GAME</code></td><td style="text-align:left;"><code>ALIPAY_MINI_GAME</code></td></tr><tr><td style="text-align:left;"><code>BYTEDANCE_GAME</code></td><td style="text-align:left;"><code>BYTEDANCE_MINI_GAME</code></td></tr></tbody></table><ul><li><strong>全局变量</strong> 变更如下：</li></ul><table><thead><tr><th style="text-align:left;">Cocos Creator 2.x</th><th style="text-align:left;">Cocos Creator 3.0</th></tr></thead><tbody><tr><td style="text-align:left;"><code>CC_BUILD</code></td><td style="text-align:left;"><code>BUILD</code></td></tr><tr><td style="text-align:left;"><code>CC_TEST</code></td><td style="text-align:left;"><code>TEST</code></td></tr><tr><td style="text-align:left;"><code>CC_EDITOR</code></td><td style="text-align:left;"><code>EDITOR</code></td></tr><tr><td style="text-align:left;"><code>CC_PREVIEW</code></td><td style="text-align:left;"><code>PREVIEW</code></td></tr><tr><td style="text-align:left;"><code>CC_DEV</code></td><td style="text-align:left;"><code>DEV</code></td></tr><tr><td style="text-align:left;"><code>CC_DEBUG</code></td><td style="text-align:left;"><code>DEBUG</code></td></tr><tr><td style="text-align:left;"><code>CC_JSB</code></td><td style="text-align:left;"><code>JSB</code></td></tr><tr><td style="text-align:left;"><code>CC_WECHATGAME</code></td><td style="text-align:left;"><code>WECHATGAME</code></td></tr><tr><td style="text-align:left;"><code>CC_RUNTIME</code></td><td style="text-align:left;"><code>RUNTIME_BASED</code></td></tr><tr><td style="text-align:left;"><code>CC_SUPPORT_JIT</code></td><td style="text-align:left;"><code>SUPPORT_JIT</code></td></tr></tbody></table><ul><li><p><strong>动态加载资源</strong>：</p><p>在 v3.0 中使用 <code>bundle.load</code> 或 <code>resources.load</code> 动态加载 <code>sprite-frame</code> 或 <code>texture</code> 时，需要将路径指定到具体的子资源：</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 加载 texture</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// v2.x</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">resources.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">load</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;background&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, cc.Texture2D, () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {});</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// v3.0</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">resources.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">load</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;background/texture&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, Texture2D, () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {});</span></span></code></pre></div><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 加载 sprite frame</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// v2.x</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">resources.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">load</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;background&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, cc.SpriteFrame, () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {});</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// v3.0</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">resources.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">load</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;background/spriteFrame&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, SpriteFrame, () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {});</span></span></code></pre></div></li></ul><h5 id="jsb-接口相关" tabindex="-1"><code>JSB</code> 接口相关 <a class="header-anchor" href="#jsb-接口相关" aria-label="Permalink to &quot;\`JSB\` 接口相关&quot;">​</a></h5><ul><li><code>jsb.FileUtils</code><ul><li><code>getDataFromFile</code> 返回类型由 <code>Uint8Array</code> 变为 <code>ArrayBuffer</code></li></ul></li></ul><h3 id="编辑器升级" tabindex="-1">编辑器升级 <a class="header-anchor" href="#编辑器升级" aria-label="Permalink to &quot;编辑器升级&quot;">​</a></h3><h4 id="构建发布面板" tabindex="-1">构建发布面板 <a class="header-anchor" href="#构建发布面板" aria-label="Permalink to &quot;构建发布面板&quot;">​</a></h4><p>Cocos Creator 3.0 中所有平台的构建都内置为插件，因此 <strong>构建发布</strong> 面板也与 v2.4 的不同，各平台独有的构建选项会单独放在一个可折叠的 section 控件内。</p><p><img src="`+o+'" alt="image"></p><p>点击 <strong>构建</strong> 按钮后会跳转到 <strong>构建任务</strong> 面板，所有构建后的平台都会显示在这个面板中。可以在这个面板中修改构建后工程的构建选项再重新构建、可以查看构建日志、打开工程目录等。如果需要返回 <strong>构建发布</strong> 面板编译其他平台的话，点击 <strong>构建任务</strong> 面板左上方的 <strong>新建构建任务</strong> 按钮即可。</p><p><img src="'+p+'" alt="image"></p><p>另外，构建时支持构建成文件分离的多模块结果，便于多模块并发加载、动态加载模块，并且微信引擎插件支持选择不同物理引擎后端。构建完成后生成的 <code>settings.js</code> 也改为 <code>settings.json</code>，并放置在 <code>src</code> 目录下，允许作为资源上传到服务器。</p><h4 id="资源缩略图面板" tabindex="-1">资源缩略图面板 <a class="header-anchor" href="#资源缩略图面板" aria-label="Permalink to &quot;资源缩略图面板&quot;">​</a></h4><p>在 <strong>资源管理器</strong> 中选中资源，即可在 <strong>资源预览</strong> 面板中显示资源的缩略图。若选中资源所在的文件夹，即可显示文件夹下所有资源的缩略图，方便查看。</p><p><img src="'+r+'" alt="image"></p><h4 id="动画编辑器升级" tabindex="-1">动画编辑器升级 <a class="header-anchor" href="#动画编辑器升级" aria-label="Permalink to &quot;动画编辑器升级&quot;">​</a></h4><ul><li>支持节点树面板中对节点的搜索与显示过滤</li><li>支持使用系统剪贴板复制粘贴节点上的所有动画数据（节点、轨道以及关键帧）</li><li>支持多选节点后批量添加属性轨道</li><li>优化关键帧选取和取消选取的操作体验（Ctrl + 鼠标点击选中关键帧可取消选中）</li><li>支持在动画编辑状态下继续编辑节点属性，包括粒子和模型材质属性等</li></ul><p><img src="'+c+'" alt="image"></p><h4 id="项目设置面板更新" tabindex="-1">项目设置面板更新 <a class="header-anchor" href="#项目设置面板更新" aria-label="Permalink to &quot;项目设置面板更新&quot;">​</a></h4><p>分成 <strong>Engine 管理器</strong>、<strong>项目设置</strong>、<strong>构建发布</strong> 三大部分。</p><p>物理碰撞组独立使用 <code>PhysicsSystem.PhysicsGroup</code> 类型，不再与 <code>Node.Layers</code> 共享分组配置：</p><p><img src="'+d+'" alt="image"></p><p><strong>压缩纹理配置</strong> 修改为在 <strong>项目设置 -&gt; 构建发布</strong> 中配置预设。在 <strong>资源管理器</strong> 中选中图片资源，然后再在 <strong>属性检查器</strong> 中选择预设的方式。<br> 旧项目升级后，编辑器会自动扫描项目内的所有压缩纹理配置情况，整理出几个预设。由于是自动扫描的，生成的名称可能不是想要的，可以自行在此处修改：</p><p><img src="'+h+'" alt="image"></p><h4 id="编辑器插件系统升级" tabindex="-1">编辑器插件系统升级 <a class="header-anchor" href="#编辑器插件系统升级" aria-label="Permalink to &quot;编辑器插件系统升级&quot;">​</a></h4><p>Cocos Creator 3.0 拥有更加强大的插件系统，编辑器几乎所有功能模块都是以插件形式存在。你可以在扩展菜单中快速创建自己的插件，从而实现自己想要的效果。另外，Cocos Creator 3.0 还提供了扩展管理器，可以轻松管理所有扩展插件的运行和卸载。</p><p><img src="'+k+'" alt="image"></p><h3 id="构建目录差异" tabindex="-1">构建目录差异 <a class="header-anchor" href="#构建目录差异" aria-label="Permalink to &quot;构建目录差异&quot;">​</a></h3><p>Cocos Creator 2.x 不同平台构建后生成的目录与 Cocos Creator 3.0 也有着一定程度上的差异。接下来我们以 v2.4.3 为例，和 v3.0 分别在 Web、原生和微信小游戏平台上进行对比。</p><h4 id="web-平台" tabindex="-1">Web 平台 <a class="header-anchor" href="#web-平台" aria-label="Permalink to &quot;Web 平台&quot;">​</a></h4><p>v2.4.3 构建 Web Desktop 平台后生成的目录：</p><p><img src="'+g+'" alt="image"></p><p>v3.0 构建 Web Desktop 平台后生成的目录：</p><p><img src="'+E+'" alt="image"></p><p>从以上两张图可以看出 Web 平台构建后生成的内容，v2.4.3 与 v3.0 大部分是相同的，不同之处包括以下几点：</p><ol><li><p>v3.0 将引擎相关的代码，例如核心模块、物理模块、插件脚本等都统一放到了 <strong>cocos-js</strong> 目录下，相比 v2.4.3 分散放在构建目录中看起来更加清晰。</p><p><img src="'+y+'" alt="image"></p></li><li><p>v2.4.3 只有一个启动脚本 <code>main.js</code>，而 v3.0 则有以下两个启动脚本：</p><ul><li><code>index.js</code>：用于做一些预处理工作</li><li><code>application.js</code>：用于启动游戏</li></ul></li><li><p>v2.4.3 中用于管理配置的 <code>src/settings.js</code> 在 v3.0 改为 <code>src/settings.json</code>。</p></li><li><p>v2.4.3 中的首屏图片 <code>splash.png</code>，在 v3.0 则默认存储在 <code>settings.json</code> 中。</p></li><li><p>v2.4.3 中的 <code>style-desktop.css</code> 和 <code>style-mobile.css</code>，在 v3.0 则合并为 <code>style.css</code>。</p></li></ol><h4 id="微信小游戏平台" tabindex="-1">微信小游戏平台 <a class="header-anchor" href="#微信小游戏平台" aria-label="Permalink to &quot;微信小游戏平台&quot;">​</a></h4><p>v2.4.3 构建微信小游戏后生成的目录：</p><p><img src="'+u+'" alt="image"></p><p>v3.0 构建微信小游戏后生成的目录：</p><p><img src="'+C+'" alt="image"></p><p>从以上两张图可以看出微信小游戏平台构建后生成的内容，v2.4.3 与 v3.0 大部分是相同的，不同之处包括以下几点：</p><ol><li><p>v3.0 将引擎相关的代码，例如核心模块、物理模块、插件脚本等都统一放到了 <code>wechatgame/cocos-js</code> 目录下。而 v2.4.3 则分散一部分放在 <code>wechatgame</code> 目录下，一部分放在 <code>wechatgame/cocos</code> 目录下。</p><p><img src="'+m+'" alt="image"></p></li><li><p>v2.4.3 将小游戏的适配层代码都编译到 <code>adapter-min.js</code> 中，而 v3.0 则是将适配层代码全部以散文件的形式存储在 <code>libs</code> 目录下，没有进行编译。</p></li><li><p>v2.4.3 的启动脚本是 <code>main.js</code>，v3.0 的启动脚本则是 <code>application.js</code>。</p></li><li><p>v2.4.3 将所有动态代码的引用记录在了 <code>ccRequire.js</code> 中，而 v3.0 目前暂时没有这个功能。</p></li><li><p>v2.4.3 中用于管理配置的 <code>src/settings.js</code> 在 v3.0 改为 <code>src/settings.json</code>。</p></li></ol><h4 id="原生平台" tabindex="-1">原生平台 <a class="header-anchor" href="#原生平台" aria-label="Permalink to &quot;原生平台&quot;">​</a></h4><p>v2.4.3 构建 Windows 平台后生成的发布包目录如下：</p><p><img src="'+F+'" alt="image"></p><p>v3.0 构建 Windows 平台后生成的发布包目录如下：</p><p><img src="'+A+'" alt="image"></p><p>从以上两张图可以看出 Windows 平台构建后生成的发布包目录，v2.4.3 与 v3.0 差异较大：</p><ol><li><p>v2.4.3 的发布包名称是以 <strong>构建发布</strong> 面板中的 <strong>构建模板</strong> 命名的（例如 <code>jsb-link</code>），v3.0 则是以 <strong>当前构建的原生平台</strong> 命名的（例如 <code>windows</code>、<code>Android</code>）。</p></li><li><p>因为各个原生平台（例如 Android、Windows）构建后生成的底层 C++ 代码是完全一致的，所以在 v3.0，我们将 v2.4.3 存放在发布包目录 <code>frameworks/runtime-src/Classes</code> 中的底层 C++ 代码单独提取出来放在共享的项目目录下的 <code>native/engine/common</code> 文件夹中。这样在构建原生平台时，如果检测到已经存在该文件夹，这部分内容便不会再进行处理，加快构建速度。</p><p><img src="'+v+'" alt="image"></p></li><li><p>v2.4.3 发布包目录中应用层相关的文件，在 v3.0 都统一合并到了 <code>assets</code> 目录中。</p><p>v2.4.3 应用层相关的文件包括：</p><ul><li><code>assets</code> 目录（资源）</li><li><code>jsb-adapter</code> 目录（适配层代码）</li><li><code>src</code> 目录（引擎相关代码、插件脚本、配置管理脚本 <code>settings.js</code> 等）</li><li>相关配置文件（<code>.cocos-project.json</code>、<code>cocos-project-template.json</code>、<code>project.json</code>）</li><li>启动脚本（<code>main.js</code>）</li></ul><p>v3.0 <code>assets</code> 目录结构如下：</p><p><img src="'+b+'" alt="image"></p><p>v3.0 在合并的过程中也做了相应的调整和改动：</p><ul><li><p>原 v2.4.3 全部放在发布包目录 <code>src</code> 目录下的引擎相关代码（例如核心模块、物理模块、插件脚本等），在 v3.0 都放到了发布包目录 <code>assets/src/cocos-js</code> 目录下。</p></li><li><p>原 v2.4.3 中用于管理配置的 <code>src/settings.js</code>，在 v3.0 改为 <code>assets/src/settings.json</code>。</p></li></ul></li><li><p>v2.4.3 会将所有原生平台的构建工程都生成在发布包目录 <code>frameworks/runtime-src</code> 目录下：</p><p><img src="'+D+'" alt="image"></p><p>而 v3.0 则是将构建工程生成在发布包目录 <code>proj</code> 目录下，且只生成当前构建平台的工程：</p><p><img src="'+x+'" alt="image"></p><p>同时，v3.0 也做了代码和配置的分离，将一部分代码和配置放入源码管理，位于项目目录下的 <code>native/engine/当前构建的平台名称</code> 文件夹中（例如 <code>native/engine/win32</code>、<code>native/engine/android</code>）。开发者可以在这里集成 SDK 或者做二次开发，删除构建后生成的发布包目录（例如 <code>build/windows</code>）不会影响已经集成的 SDK。</p><p><img src="'+f+'" alt="image"></p></li><li><p>一些编译时需要用到的资源，例如应用图标、应用启动脚本等，v2.4.3 是存储在构建工程中，而 v3.0 则是存储在项目目录的 <code>native/engine/当前构建的平台名称</code> 文件夹中。</p></li></ol><h2 id="升级常见问题-faq" tabindex="-1">升级常见问题（FAQ） <a class="header-anchor" href="#升级常见问题-faq" aria-label="Permalink to &quot;升级常见问题（FAQ）&quot;">​</a></h2><h3 id="升级后项目脚本在-vs-code-打开时-绑定组件定义等操作出现报红现象" tabindex="-1">升级后项目脚本在 VS Code 打开时，绑定组件定义等操作出现报红现象 <a class="header-anchor" href="#升级后项目脚本在-vs-code-打开时-绑定组件定义等操作出现报红现象" aria-label="Permalink to &quot;升级后项目脚本在 VS Code 打开时，绑定组件定义等操作出现报红现象&quot;">​</a></h3><p>Cocos Creator 3.x 开启了 TypeScript 的严格模式，会对代码进行更严格的审查，排除开发过程中可能会出现的因为疏忽而导致的问题。</p><p>如果不想使用严格模式，可以在 Creator 顶部菜单栏的 <strong>项目 -&gt; 项目设置 -&gt; 脚本</strong> 中勾选 <strong>启用宽松模式</strong>。需要提醒的是，我们并不鼓励关闭严格模式，因为严格空值检查能够减少代码运行时的一些低级报错。</p><p>关于严格模式下的书写规范，可以参照官方案例 <strong>快上车 3D</strong>（<a href="https://github.com/cocos/cocos-tutorial-taxi-game" target="_blank" rel="noreferrer">GitHub</a> | <a href="https://gitee.com/mirrors_cocos-creator/tutorial-taxi-game" target="_blank" rel="noreferrer">Gitee</a>）。</p><h3 id="action-动作全都失效" tabindex="-1">Action 动作全都失效 <a class="header-anchor" href="#action-动作全都失效" aria-label="Permalink to &quot;Action 动作全都失效&quot;">​</a></h3><p>因为 Cocos Creator 3.x 移除了 Action 动作系统，统一使用 Tween 缓动系统。</p><h3 id="修改-2d-节点的-size-和-anchor-不生效" tabindex="-1">修改 2D 节点的 <code>size</code> 和 <code>anchor</code> 不生效 <a class="header-anchor" href="#修改-2d-节点的-size-和-anchor-不生效" aria-label="Permalink to &quot;修改 2D 节点的 `size` 和 `anchor` 不生效&quot;">​</a></h3><p>需要先获取节点上的 UITransform 组件，再使用对应的接口，例如：</p><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> uiTrans</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> node.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getComponent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(UITransform)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">uiTrans.anchorX </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0.5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">uiTrans.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setContentSize</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(size);</span></span></code></pre></div><h3 id="修改-2d-节点的-color-不生效" tabindex="-1">修改 2D 节点的 <code>color</code> 不生效 <a class="header-anchor" href="#修改-2d-节点的-color-不生效" aria-label="Permalink to &quot;修改 2D 节点的 `color` 不生效&quot;">​</a></h3><p>需要先获取节点上的渲染组件（例如 Sprite 组件），再使用对应的接口，例如：</p><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> uiColor</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> node.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getComponent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Sprite)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">uiColor.color </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> color</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">255</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">255</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">255</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div><h3 id="修改-2d-节点的-skew-不生效" tabindex="-1">修改 2D 节点的 <code>skew</code> 不生效 <a class="header-anchor" href="#修改-2d-节点的-skew-不生效" aria-label="Permalink to &quot;修改 2D 节点的 `skew` 不生效&quot;">​</a></h3><p>从 v3.0 开始，<code>skew</code> 接口已经被移除。</p><h3 id="无法获取分组-但-creator-的项目设置面板中仍有分组设置-layers" tabindex="-1">无法获取分组，但 Creator 的项目设置面板中仍有分组设置（Layers） <a class="header-anchor" href="#无法获取分组-但-creator-的项目设置面板中仍有分组设置-layers" aria-label="Permalink to &quot;无法获取分组，但 Creator 的项目设置面板中仍有分组设置（Layers）&quot;">​</a></h3><p>v2.x 的 <code>group</code> 分组管理从 v3.0 开始变更为 <code>Layer</code>，如下图所示。在 v2.x 中通过 <code>node.group</code> 获取到的是分组名，而在 v3.x 通过 <code>node.layer</code> 获取到的是 <strong>分组值</strong>，并且分组值是以 2 的指数幂设定。</p><p><img src="'+_+`" alt="update-setting"></p><p>User Layer 0 的 layer 值为：2<sup>0</sup> = 1。<br> User Layer 1 的 layer 值为：2<sup>1</sup> = 2。<br> User Layer 6 的 layer 值为：2<sup>6</sup> = 64。</p><h3 id="通过-zindex-设置同级节点失效" tabindex="-1">通过 <code>zIndex</code> 设置同级节点失效 <a class="header-anchor" href="#通过-zindex-设置同级节点失效" aria-label="Permalink to &quot;通过 \`zIndex\` 设置同级节点失效&quot;">​</a></h3><p>从 v3.0 开始 <code>zIndex</code> 接口已经被移除，若需要调整节点树的顺序请使用 <code>setSiblingIndex</code> 方法来替换使用。</p><h3 id="通过-getcomponent-无法获取到节点上挂载的脚本" tabindex="-1">通过 <code>getComponent()</code> 无法获取到节点上挂载的脚本 <a class="header-anchor" href="#通过-getcomponent-无法获取到节点上挂载的脚本" aria-label="Permalink to &quot;通过 \`getComponent()\` 无法获取到节点上挂载的脚本&quot;">​</a></h3><p>请查询对应脚本的类名，而不是脚本名，因为在 v3.x 中脚本组件是以脚本中定义的类名为准的，而不是脚本名。常出现因为大小写而导致脚本找不到的问题。详情请参考 <a href="./../scripting/setup">创建脚本</a>。</p><h3 id="动态加载-resources-文件夹下的图片时提示找不到" tabindex="-1">动态加载 <code>resources</code> 文件夹下的图片时提示找不到 <a class="header-anchor" href="#动态加载-resources-文件夹下的图片时提示找不到" aria-label="Permalink to &quot;动态加载 \`resources\` 文件夹下的图片时提示找不到&quot;">​</a></h3><p>图片设置为 <code>sprite-frame</code>、<code>texture</code> 或其他图片类型后，将会在 <strong>资源管理器</strong> 中生成一个对应类型的资源。但如果直接加载 <code>testAssets/image</code>，得到的类型将会是 <code>ImageAsset</code>，必须指定路径到具体的子资源。</p><p>例如一张设置为 <code>sprite-frame</code> 类型的图片在 <code>resources</code> 文件夹下的路径为 <code>testAssets/image</code>，那么要加载 <code>SpriteFrame</code> 应该这么写：</p><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">resources.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">load</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;testAssets/image/spriteFrame&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, SpriteFrame, (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">err</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">spriteFrame</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.node.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getComponent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Sprite).spriteFrame </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> spriteFrame;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre></div><p>若加载的是 <code>texture</code> 类型的图片，则将 <code>spriteFrame</code> 修改为 <code>texture</code> 即可。</p><h3 id="物体产生物理碰撞之后-原有的物理碰撞回调没有了" tabindex="-1">物体产生物理碰撞之后，原有的物理碰撞回调没有了 <a class="header-anchor" href="#物体产生物理碰撞之后-原有的物理碰撞回调没有了" aria-label="Permalink to &quot;物体产生物理碰撞之后，原有的物理碰撞回调没有了&quot;">​</a></h3><p>从 v3.0 开始，碰撞体回调需要在开始的时候进行注册，与原先 v2.x 会直接产生回调不同。因此开发者需要在物理回调的脚本中增加对回调函数的注册。例如：</p><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> collider </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getComponent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Collider2D);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (collider) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 只在两个碰撞体开始接触时被调用一次</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    collider.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">on</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Contact2DType.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">BEGIN_CONTACT</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.onBeginContact, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 只在两个碰撞体结束接触时被调用一次</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    collider.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">on</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Contact2DType.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">END_CONTACT</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.onEndContact, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 每次将要处理碰撞体接触逻辑时被调用</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    collider.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">on</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Contact2DType.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">PRE_SOLVE</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.onPreSolve, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 每次处理完碰撞体接触逻辑时被调用</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    collider.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">on</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Contact2DType.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">POST_SOLVE</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.onPostSolve, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre></div><h3 id="升级之后-物理碰撞分组不见了" tabindex="-1">升级之后，物理碰撞分组不见了 <a class="header-anchor" href="#升级之后-物理碰撞分组不见了" aria-label="Permalink to &quot;升级之后，物理碰撞分组不见了&quot;">​</a></h3><p>目前导入插件还不支持物理碰撞矩阵，因此暂时需要开发者手动设置碰撞矩阵，可在 Creator 主菜单 <strong>项目 -&gt; 项目设置 -&gt; 物理</strong> 中重新设置。</p><h3 id="音频系统的-audioengine-接口失效-无法播放音频" tabindex="-1">音频系统的 <code>audioEngine</code> 接口失效，无法播放音频 <a class="header-anchor" href="#音频系统的-audioengine-接口失效-无法播放音频" aria-label="Permalink to &quot;音频系统的 \`audioEngine\` 接口失效，无法播放音频&quot;">​</a></h3><p>从 v3.0 开始，移除了 <code>audioEngine</code> 接口，统一使用 <strong>AudioSource</strong> 组件来控制音频的播放。详情请参考 <a href="./../audio-system/audiosource">AudioSource 组件</a>。</p><h3 id="button-按钮无法点击" tabindex="-1">Button 按钮无法点击 <a class="header-anchor" href="#button-按钮无法点击" aria-label="Permalink to &quot;Button 按钮无法点击&quot;">​</a></h3><p>排除代码和渲染层级问题，请查看 <strong>Button</strong> 节点的 <code>Scale</code> 属性中 <code>Z</code> 轴的值是否为 0，如果是，将其修改为 1 即可。</p><h3 id="升级后对脚本进行修改-出现编辑器卡死的情况" tabindex="-1">升级后对脚本进行修改，出现编辑器卡死的情况 <a class="header-anchor" href="#升级后对脚本进行修改-出现编辑器卡死的情况" aria-label="Permalink to &quot;升级后对脚本进行修改，出现编辑器卡死的情况&quot;">​</a></h3><p>检查升级后脚本中定义的组件类型的属性装饰器 <code>property</code> 是否未定义，如果未定义，则是由于导入插件太过于老旧导致的，请参考 <a href="https://github.com/cocos-creator/plugin-import-2.x" target="_blank" rel="noreferrer">插件升级</a> 对导入插件进行更新升级。更新导入插件后，需要 <strong>重新进行项目升级</strong>。</p><h3 id="升级后在脚本中修改节点的-position-时-直接通过节点-例如-node-x-修改不生效" tabindex="-1">升级后在脚本中修改节点的 <code>Position</code> 时，直接通过节点（例如 <code>node.x</code>）修改不生效 <a class="header-anchor" href="#升级后在脚本中修改节点的-position-时-直接通过节点-例如-node-x-修改不生效" aria-label="Permalink to &quot;升级后在脚本中修改节点的 \`Position\` 时，直接通过节点（例如 \`node.x\`）修改不生效&quot;">​</a></h3><p>从 v3.0 开始，<code>node</code> 节点上不允许直接访问坐标位置，需要先访问 <code>position</code> 再访问坐标值。并且 v3.x 中的 <code>position</code> 为 <strong>只读属性</strong>，若需要修改，请使用 <code>setPosition</code> 方法。例如：</p><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// v2.x</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 访问坐标轴</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> xAxis </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.node.x;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 修改 X 轴坐标</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.node.x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 200</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// v3.x</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 访问坐标轴</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> xAxis </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.node.position.x;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 修改 X 轴坐标</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.node.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setPosition</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">200</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div><h2 id="typescript-参考教程" tabindex="-1">TypeScript 参考教程 <a class="header-anchor" href="#typescript-参考教程" aria-label="Permalink to &quot;TypeScript 参考教程&quot;">​</a></h2><ul><li><a href="https://forum.cocos.org/t/topic/106995" target="_blank" rel="noreferrer">Cocos Creator 3.0 TypeScript 问题答疑及经验分享</a></li><li><a href="https://www.typescriptlang.org/" target="_blank" rel="noreferrer">TypeScript 官方网站</a></li><li><a href="https://www.typescriptlang.org/docs/handbook/classes.html" target="_blank" rel="noreferrer">TypeScript - Classes</a></li><li><a href="https://www.typescriptlang.org/docs/handbook/decorators.html" target="_blank" rel="noreferrer">TypeScript - Decorators</a></li><li><a href="http://definitelytyped.org/" target="_blank" rel="noreferrer">TypeScript - DefinitelyTyped</a></li><li><a href="https://learnxinyminutes.com/docs/zh-cn/typescript-cn/" target="_blank" rel="noreferrer">X 分钟速成 TypeScript</a></li><li><a href="https://github.com/Microsoft/TypeScript" target="_blank" rel="noreferrer">TypeScript 源码</a></li><li><a href="https://mp.weixin.qq.com/s/7QQJxErt2-e4jLK2_4GUFA" target="_blank" rel="noreferrer">开发者回避使用 TypeScript 的三个借口 — 以及应当使用 TypeScript 的更有说服力的原因</a></li></ul>`,128),S=[q];function T(P,I,w,j,M,U){return e(),i("div",null,S)}const R=s(B,[["render",T]]);export{G as __pageData,R as default};
