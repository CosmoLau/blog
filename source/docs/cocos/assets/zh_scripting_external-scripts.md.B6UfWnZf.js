import{_ as s,c as t,o as a,a4 as i}from"./chunks/framework.uQk9_EO2.js";const e="/docs/cocos/assets/import-as-plugin.C0PZTuKW.png",l="/docs/cocos/assets/sort-plugin.Cnfob0hK.png",u=JSON.parse('{"title":"外部代码支持","description":"","frontmatter":{},"headers":[],"relativePath":"zh/scripting/external-scripts.md","filePath":"zh/scripting/external-scripts.md","lastUpdated":1712305443000}'),n={name:"zh/scripting/external-scripts.md"},r=i('<h1 id="外部代码支持" tabindex="-1">外部代码支持 <a class="header-anchor" href="#外部代码支持" aria-label="Permalink to &quot;外部代码支持&quot;">​</a></h1><blockquote><p><strong>注意</strong>：Cocos Creator 3.x 推荐使用模块代替插件脚本的使用！</p></blockquote><h2 id="插件脚本" tabindex="-1">插件脚本 <a class="header-anchor" href="#插件脚本" aria-label="Permalink to &quot;插件脚本&quot;">​</a></h2><p>当脚本资源导入到 <strong>资源管理器</strong> 后，在 <strong>属性检查器</strong> 中设置了 <strong>导入为插件</strong>，此脚本资源便称为 <strong>插件脚本</strong>。插件脚本通常用于引入第三方库。目前仅支持 JavaScript 插件脚本。</p><p><img src="'+e+`" alt="import as plugin"></p><p>与项目中的其它脚本不同，Creator 不会修改插件脚本的内容，但可能会插入一些代码以适配 Creator。特别地，Creator 将屏蔽全局变量 <code>module</code>、<code>exports</code>、<code>define</code>。</p><h3 id="导入选项" tabindex="-1">导入选项 <a class="header-anchor" href="#导入选项" aria-label="Permalink to &quot;导入选项&quot;">​</a></h3><p>许多第三方 JavaScript 库以全局变量的方式提供库的功能，这些库往往会写入全局变量 <code>window</code>、<code>global</code>、<code>self</code> 和 <code>this</code> 中，但这些全局变量不一定是跨平台的。为了方便，Creator 在导入插件脚本时，提供了 <strong>全局变量别名</strong> 选项，开启后，Creator 将插入必要的代码以模拟这些全局变量，其效果类似于：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> window</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> globalThis;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> global</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> globalThis;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> self</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> globalThis;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        /* 原始代码 */</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">call</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">call</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div><p>默认会模拟常见的全局变量，如果是特殊的全局变量别名，可以在输入框内添加对应的变量名称。</p><h3 id="执行时机" tabindex="-1">执行时机 <a class="header-anchor" href="#执行时机" aria-label="Permalink to &quot;执行时机&quot;">​</a></h3><h4 id="执行环境" tabindex="-1">执行环境 <a class="header-anchor" href="#执行环境" aria-label="Permalink to &quot;执行环境&quot;">​</a></h4><p>开发者可以控制插件脚本在某些环境下是否执行。</p><table><thead><tr><th style="text-align:left;">选项</th><th style="text-align:left;">影响平台</th><th style="text-align:left;">备注</th></tr></thead><tbody><tr><td style="text-align:left;">允许 Web 平台加载</td><td style="text-align:left;">浏览器、网页预览、编辑器</td><td style="text-align:left;">默认启用，禁用时会连带 <strong>允许编辑器加载</strong> 一起禁用</td></tr><tr><td style="text-align:left;">允许编辑器加载</td><td style="text-align:left;">编辑器</td><td style="text-align:left;">默认禁用，如果编辑器中的其它普通脚本加载过程中会依赖当前脚本，则需要 <strong>手动开启</strong> 这个选项。<br>开启后，脚本内不在任何函数内声明的局部变量 <strong>不会</strong> 暴露成全局变量，所以全局变量需要用 <code>window.abc = 0</code> 的方式定义才能生效。</td></tr><tr><td style="text-align:left;">允许 Native 平台加载</td><td style="text-align:left;">原生平台、模拟器预览</td><td style="text-align:left;">默认启用</td></tr><tr><td style="text-align:left;">允许小游戏平台加载</td><td style="text-align:left;">小游戏平台</td><td style="text-align:left;">默认启用</td></tr></tbody></table><h4 id="执行顺序" tabindex="-1">执行顺序 <a class="header-anchor" href="#执行顺序" aria-label="Permalink to &quot;执行顺序&quot;">​</a></h4><p>插件脚本默认将会在引擎启动后，项目脚本加载前执行。插件脚本之间的顺序默认按照插件脚本本身的命名来排序。自 3.8.3 起可以在项目设置内指定插件脚本的优先级顺序，指定了优先级顺序的脚本会在默认排序后再次调整脚本的位置使其符合指定的顺序要求。</p><blockquote><p>具体项目设置的修改交互方式可以参考 <a href="./../editor/project/#插件脚本排序">项目设置文档</a></p></blockquote><p><img src="`+l+'" alt="sort plugin script"></p><p>例如假设有插件脚本名称分别为：<code>1,2,3,4,5,6,7,8</code>, 默认的排序顺序将会从 1 - 8 排序，如果此时项目设置内指定了部分脚本的优先级顺序为：<code>8,3,1,7,5</code>，则最终的排序结果为：<code>8,3,1,2,4,7,5,6</code>。</p><h3 id="可用性与跨平台" tabindex="-1">可用性与跨平台 <a class="header-anchor" href="#可用性与跨平台" aria-label="Permalink to &quot;可用性与跨平台&quot;">​</a></h3><p>插件脚本几乎会原封不动地拷贝到构建目录，因此插件脚本的可用性与跨平台性不受 Creator 保障。例如，当插件脚本使用了某些平台不支持的语言特性时将导致错误：</p><ul><li><p><strong>目标平台不提供原生 node.js 支持</strong></p><p>例如很多 <a href="https://www.npmjs.com/" target="_blank" rel="noreferrer">npm</a> 模块都直接或间接依赖于 <code>node.js</code>，这样的话发布到原生或网页平台后是不能用的。</p></li><li><p><strong>依赖 DOM API 的插件将无法发布到原生平台</strong></p><p>网页中可以使用大量的前端插件，例如 jQuery，不过它们有可能依赖于浏览器的 DOM API。依赖这些 API 的插件不能用于原生平台中。</p></li></ul><h3 id="交互" tabindex="-1">交互 <a class="header-anchor" href="#交互" aria-label="Permalink to &quot;交互&quot;">​</a></h3><p>插件脚本与非插件脚本无法以导入形式交互。举例来说，即使开发者知道其目标平台实际支持 CommonJS，也不能在非插件脚本中强行通过 <code>require</code> 相对路径进行使用。</p><p>因此，插件脚本一般以全局变量的方式（又称 IIFE 模块格式）来通讯，但需要注意以下几点：</p><ul><li>谨慎使用全局变量，当开发者要用全局变量时，应该清楚自己在做什么，我们并不推荐滥用全局变量，即使要用也最好保证全局变量为 <strong>只读</strong> 状态。</li><li>添加全局变量时，请小心不要和系统已有的全局变量重名。</li><li>开发者可以在插件脚本中自由封装或者扩展 Cocos Creator 引擎，但这会提高团队沟通成本，导致脚本难以复用。</li></ul>',26),o=[r];function h(p,d,c,k,g,E){return a(),t("div",null,o)}const f=s(n,[["render",h]]);export{u as __pageData,f as default};
