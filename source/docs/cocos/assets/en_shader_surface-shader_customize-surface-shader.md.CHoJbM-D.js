import{_ as s,E as t,c as n,m as e,a,J as l,w as o,a4 as h,o as r}from"./chunks/framework.uQk9_EO2.js";const b=JSON.parse('{"title":"Customize Surface Shader","description":"","frontmatter":{},"headers":[],"relativePath":"en/shader/surface-shader/customize-surface-shader.md","filePath":"en/shader/surface-shader/customize-surface-shader.md","lastUpdated":1712305443000}'),c={name:"en/shader/surface-shader/customize-surface-shader.md"},d=h(`<h1 id="customize-surface-shader" tabindex="-1">Customize Surface Shader <a class="header-anchor" href="#customize-surface-shader" aria-label="Permalink to &quot;Customize Surface Shader&quot;">​</a></h1><p>Indeed, while the Surface Shader provides a lighting model that can adapt to most scene materials, its functionality is relatively fixed.</p><p>Sometimes, users need to use completely customized lighting calculations and color calculations. For example, some special, stylized materials require outline lights, additional fill lights, unrealistic environmental lighting, etc.</p><p>For such extremely special situations, the Surface Shader also provides customization capabilities.</p><p>However, it should be noted that because the surface material data and lighting calculation process are intervened, the rendering effect may produce unexpected.</p><h2 id="_1-customize-vs-output-and-fs-input" tabindex="-1">1. Customize VS Output and FS Input <a class="header-anchor" href="#_1-customize-vs-output-and-fs-input" aria-label="Permalink to &quot;1. Customize VS Output and FS Input&quot;">​</a></h2><p>We can define a new varying variable in the VS stage and then calculate and output the value of this variable in a certain Surface function.</p><p>After defining a variable with the same name in the FS stage, we can get and use the value of this variable in a certain Surface function.</p><p>For details, please refer to <a href="./fs-input">Fragment Shader Input</a>.</p><h2 id="_2-custom-material-data" tabindex="-1">2. Custom Material Data <a class="header-anchor" href="#_2-custom-material-data" aria-label="Permalink to &quot;2. Custom Material Data&quot;">​</a></h2><p>Add the following code in the VS function.</p><div class="language-glsl vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">glsl</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//PBR lighting mode</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#include</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &lt;surfaces/data-structures/standard&gt;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// toon lighting mode</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//#include &lt;surfaces/data-structures/toon&gt; </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#define</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> CC_SURFACES_FRAGMENT_MODIFY_SHARED_DATA</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> SurfacesFragmentModifySharedData</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(inout SurfacesMaterialData </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">surfaceData</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // set user-defined data to surfaceData</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>The <code>#include</code> at the beginning of the function is used to determine the data structure of the surface material. Different <code>SurfacesMaterialData</code> structures will be used according to different included files.</p><p>For specific content, you can check the <strong>standard.chunk</strong> and <strong>toon.chunk</strong> under the <strong>internal/chunks/surfaces/data-structures/</strong> directory.</p><p>After defining the <code>CC_SURFACES_FRAGMENT_MODIFY_SHARED_DATA</code> macro, the Shader compiler will choose your own <code>SurfacesFragmentModifySharedData</code> to replace the default function.</p><p>This function will be called during the vs stage, specifically, you can check the <strong>render-to-scene/vs.chunk</strong> and <strong>render-to-shadowmap/vs.chunk</strong> files under the <strong>internal/chunks/shading-entries/main-functions/</strong> directory.</p><p>In this function, we can directly modify the properties in surfaceData to prepare for the lighting stage.</p><h2 id="customize-lighting-results" tabindex="-1">Customize Lighting Results <a class="header-anchor" href="#customize-lighting-results" aria-label="Permalink to &quot;Customize Lighting Results&quot;">​</a></h2><p>With the custom SurfacesMaterialData from above, we also need to work with the lighting stage to achieve the calculation results we want.</p><p>In the FS, add the following code.</p><div class="language-glsl vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">glsl</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#include</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &lt;lighting-models/includes/common&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#define</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> CC_SURFACES_LIGHTING_MODIFY_FINAL_RESULT</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> SurfacesLightingModifyFinalResult</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(inout LightingResult </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">result</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, in LightingIntermediateData </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">lightingData</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, in SurfacesMaterialData </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">surfaceData</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, in LightingMiscData </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">miscData</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // use surfaceData and lightingData for customizing lighting result</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>This function will be called in fs.chunk.</p><p>As we can see, the function has 4 parameters.</p><ul><li>LightingIntermediateData: Data needed for lighting calculation, such as normal, view direction, view distance, etc.</li><li>SurfacesMaterialData: PBR-related parameters, such as color, normal, etc.</li><li>LightingMiscData: Light source data, such as position, direction, color, intensity, etc.</li><li>LightingResult: Used to return lighting results, such as diffuse, specular, shadow, ao, etc.</li></ul><p>In this function, you can use lighting and material data to perform the lighting calculations and store them in the result.</p><p>For local lights(point light or spotlight), this function will be executed per light. That means if an object is affected by 6 lights, this function will be called 6 times.</p>`,26),u=e("p",null,"For example, if you want to use the built-in lighting functions of the PBR lighting model in the function, you can include the lighting-models/includes/standard header file.",-1),p=e("p",null,"This header file will include lighting-models/model-functions/standard.",-1),g=e("p",null,"All built-in functions related to PBR lighting are here, just call them directly.",-1),f=e("h2",{id:"more-customizations",tabindex:"-1"},[a("More Customizations "),e("a",{class:"header-anchor",href:"#more-customizations","aria-label":'Permalink to "More Customizations"'},"​")],-1),k=e("p",null,"If the above customization mechanism still cannot meet your needs, it is recommended to refer to chunks/shading-entries to build your own main function and control the entire shading process.",-1);function m(y,E,_,F,S,D){const i=t("font");return r(),n("div",null,[d,e("p",null,[a("If you want to "),l(i,{color:"#ff0000"},{default:o(()=>[a("directly call the built-in lighting module functions within the overloaded function.")]),_:1}),a(", you can change lighting-models/includes/common to the header file used by the corresponding lighting model.")]),u,p,g,f,k])}const v=s(c,[["render",m]]);export{b as __pageData,v as default};
