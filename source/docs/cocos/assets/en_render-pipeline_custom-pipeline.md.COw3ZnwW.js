import{_ as s,c as i,o as e,a4 as a}from"./chunks/framework.uQk9_EO2.js";const t="/docs/cocos/assets/cp-render-graph-1.C1YQAlGh.png",n="/docs/cocos/assets/cp-render-graph-2.BmjqGvSc.png",p="/docs/cocos/assets/cp-raster-pass.BJV15oH9.png",r="/docs/cocos/assets/cp-compute-pass.D0lW3WLN.png",h="/docs/cocos/assets/cp-copy-pass.calDGw4E.png",l="/docs/cocos/assets/cp-raster-view.CluP7aTj.png",o="/docs/cocos/assets/cp-compute-view.DlH4ZM5d.png",k="/docs/cocos/assets/cp-add-raster-view.BIAVRw2i.png",d="/docs/cocos/assets/cp-add-compute-view.5DMu6208.png",c="/docs/cocos/assets/cp-add-raster-queue.D1cplyNh.png",g="/docs/cocos/assets/cp-raster-queue.DPFHZB63.png",E="/docs/cocos/assets/cp-add-compute-queue.lb8799Pt.png",u="/docs/cocos/assets/cp-dispatch.DtBcIRv3.png",y="/docs/cocos/assets/cp-scene.CSVhL38p.png",m="/docs/cocos/assets/cp-quad.fcWeKD47.png",F="/docs/cocos/assets/cp-dispatch.DtBcIRv3.png",f="/docs/cocos/assets/cp-setter.RnGIAlaI.png",C="/docs/cocos/assets/cp-data-structure.CG1o8xxE.png",w="/docs/cocos/assets/cp-feature-enable.Dp91Jdnk.png",D="/docs/cocos/assets/cp-pipeline-selection.Bm8E8KUB.png",P="/docs/cocos/assets/postprocessPass.Bu9X6shB.png",b="/docs/cocos/assets/postprocessOutput.ucZ8jX-r.png",A="/docs/cocos/assets/testCustomPipeline.I_5ddPS4.png",R="/docs/cocos/assets/customPipelineBloom.mKuM104W.png",O=JSON.parse('{"title":"Custom Render Pipeline(experimental)","description":"","frontmatter":{},"headers":[],"relativePath":"en/render-pipeline/custom-pipeline.md","filePath":"en/render-pipeline/custom-pipeline.md","lastUpdated":1712305443000}'),B={name:"en/render-pipeline/custom-pipeline.md"},_=a('<h1 id="custom-render-pipeline-experimental" tabindex="-1">Custom Render Pipeline(experimental) <a class="header-anchor" href="#custom-render-pipeline-experimental" aria-label="Permalink to &quot;Custom Render Pipeline(experimental)&quot;">​</a></h1><p>A new <strong>Custom Render Pipeline</strong> has been added in Cocos Creator 3.6.</p><p>The interface and naming are not yet stable and are not recommended for use in formal projects. Currently, only the web platform is supported.</p><p>The interface of the <strong>custom rendering pipeline</strong> is located in <code>cocos/core/pipeline/custom/pipeline.ts</code></p><h2 id="overview" tabindex="-1">Overview <a class="header-anchor" href="#overview" aria-label="Permalink to &quot;Overview&quot;">​</a></h2><p>The <strong>CustomPipeline</strong> allows users to customize the <strong>RenderPass</strong>, set the input/output <strong>RenderView</strong>, and the <strong>RenderContent</strong> to be drawn for each <strong>RenderPass</strong>.</p><p><strong>Render content</strong> can be a <strong>Scene</strong>, a screen <strong>Quad</strong>, or a <strong>Dispatch</strong> of a computational task, depending on the type of <strong>RenderPass</strong>.</p><p>The order in which <strong>rendered content</strong> is drawn can be adjusted by a <strong>RenderQueue</strong> (RenderQueue).</p><p>The [<strong>RenderPass</strong>, <strong>RenderQueue</strong>, <strong>RenderContent</strong>] of <strong>CustomRenderPipeline</strong> constitute a forest of.</p><p><img src="'+t+'" width="640"></p><p><strong>Custom Rendering Pipeline</strong> of [<strong>Render Pass</strong>, <strong>Render View</strong>] constitutes a directed acyclic graph (DAG).</p><p><img src="'+n+'" width="640"></p><p>We can stack the above two graphs to get the <strong>RenderGraph</strong>. The <strong>RenderGraph</strong> describes the entire flow of the <strong>Custom Render Pipeline</strong>, and the engine will allocate resources, optimize the flow, and execute the rendering according to the user&#39;s customized flow graph.</p><h2 id="renderpass" tabindex="-1">RenderPass <a class="header-anchor" href="#renderpass" aria-label="Permalink to &quot;RenderPass&quot;">​</a></h2><p><strong>RenderPass</strong> There are three types: Raster, Compute, and Resource.</p><p>Each type will have its own different <strong>RenderPass</strong>.</p><h3 id="raster" tabindex="-1">Raster <a class="header-anchor" href="#raster" aria-label="Permalink to &quot;Raster&quot;">​</a></h3><p>The raster type uses the rasterization capabilities of the GPU (executed in GraphicsEngine).</p><h4 id="_1-rasterpass" tabindex="-1">1. RasterPass <a class="header-anchor" href="#_1-rasterpass" aria-label="Permalink to &quot;1. RasterPass&quot;">​</a></h4><p><img src="'+p+'" width="760"></p><ul><li><p>width, height is the resolution of the output rendering target.</p></li><li><p>layoutName is the name of the Effect&#39;s Stage.</p></li><li><p>name is the name displayed during debugging. If it is empty, the system will give the default name.</p></li></ul><h4 id="_2-rastersubpass" tabindex="-1">2. RasterSubpass <a class="header-anchor" href="#_2-rastersubpass" aria-label="Permalink to &quot;2. RasterSubpass&quot;">​</a></h4><p>Feature not yet open. Requires GPU Tile-based rendering capability.</p><h4 id="_3-presentpass" tabindex="-1">3. PresentPass <a class="header-anchor" href="#_3-presentpass" aria-label="Permalink to &quot;3. PresentPass&quot;">​</a></h4><p>Present the content to the screen.</p><h3 id="compute" tabindex="-1">Compute <a class="header-anchor" href="#compute" aria-label="Permalink to &quot;Compute&quot;">​</a></h3><p>The compute type uses the general-purpose computing power of the GPU, as well as ray-tracing capabilities (executable in GraphicsEngine, ComputeEngine).</p><h4 id="_1-computepass" tabindex="-1">1. ComputePass <a class="header-anchor" href="#_1-computepass" aria-label="Permalink to &quot;1. ComputePass&quot;">​</a></h4><p><img src="'+r+'" width="760"></p><ul><li><p>layoutName is the name of the Effect&#39;s Stage.</p></li><li><p>name is the name displayed during debugging. If it is empty, the system will give the default name.</p></li></ul><h4 id="_2-raytracepass" tabindex="-1">2. RaytracePass <a class="header-anchor" href="#_2-raytracepass" aria-label="Permalink to &quot;2. RaytracePass&quot;">​</a></h4><p>Feature not yet open. Requires GPU ray tracing capability.</p><h3 id="resource" tabindex="-1">Resource <a class="header-anchor" href="#resource" aria-label="Permalink to &quot;Resource&quot;">​</a></h3><p>The resource type uses the resource processing power of the GPU (executable in GraphicsEngine, ComputeEngine, CopyEngine).</p><h4 id="_1-copypass" tabindex="-1">1. CopyPass <a class="header-anchor" href="#_1-copypass" aria-label="Permalink to &quot;1. CopyPass&quot;">​</a></h4><p>Responsible for copying the resource source to the target, which requires the resource format to be compatible.</p><p><img src="'+h+'" width="760"></p><ul><li>name is the name displayed during debugging. If it is empty, the system will give the default name.</li></ul><h4 id="_2-movepass" tabindex="-1">2. MovePass <a class="header-anchor" href="#_2-movepass" aria-label="Permalink to &quot;2. MovePass&quot;">​</a></h4><p>Responsible for moving the resource source to the target, requiring the resource to be in the same format.</p><p>Move here is a semantic concept (move semantics): move the source variable to the target variable, expiring the source variable. If the resource cannot be moved for some reason (e.g. the resource source is being read), this is done as a copy.</p><p>Move semantics are used for pipeline optimization for the purpose of bandwidth reduction. If you are not sure how to use <strong>Move Pass</strong> properly, you can use <strong>Copy Pass</strong> instead, which will not affect the rendering result and is easier to debug.</p><h2 id="renderview" tabindex="-1">RenderView <a class="header-anchor" href="#renderview" aria-label="Permalink to &quot;RenderView&quot;">​</a></h2><p>There are two types of RenderView: <strong>RasterView</strong>, <strong>ComputeView</strong>.</p><h3 id="rasterview" tabindex="-1">RasterView <a class="header-anchor" href="#rasterview" aria-label="Permalink to &quot;RasterView&quot;">​</a></h3><p><strong>Rasterized view</strong> will be rasterized. There are two subtypes: RenderTarget, DepthStencil.</p><p><img src="'+l+'" width="560"></p><ul><li><p>slotName is the name of the shader pixel component. (e.g. color, normal, etc.)</p></li><li><p>accessType is the binding type, which can be Read, ReadWrite, Write, Read as input, Write as output, ReadWrite as both input and output, [Note] DepthStencil When doing DepthTest, although the result is not written to the view, but as output, the binding type is still Write. some platforms open ARM_shader_framebuffer_fetch_depth_stencil extension, DepthStencil binding type is ReadWrite.-&gt; When ARM_shader_framebuffer_fetch_depth_stencil extension is enabled in a shader, the corresponding DepthStencil binding type should be set to ReadWrite</p></li><li><p>attachmentType is the type, can be RenderTarget or DepthStencil.</p></li><li><p>loadOp is the rasterized read option, which can be Read, Clear, or Discard.</p></li><li><p>storeOp is the rasterized store option, can be Write (Store), Discard (Discard).</p></li><li><p>clearFlags is the clear flag bit, if the type is RenderTarget, the flag bit must be Color. if the type is DepthStencil, it is one of Depth, Stencil, Depth | Stencil.</p></li><li><p>clearColor is the clear color, if the type is RenderTarget, it is RGBA (Float4). If the type is DepthStencil, it is RG, where R stores Depth (Float) and G stores Stencil (Uint8).</p></li></ul><h3 id="computeview" tabindex="-1">ComputeView <a class="header-anchor" href="#computeview" aria-label="Permalink to &quot;ComputeView&quot;">​</a></h3><p><strong>Computed view</strong> will not be rasterized. Commonly used for Samples, Unordered Access.</p><p><img src="'+o+'" width="520"></p><ul><li><p>name is the name of the Shader descriptor (Descriptor).</p></li><li><p>accessType is the read/write type. It can be Read, ReadWrite, or Write.</p></li><li><p>clearFlags is the clear type of the resource, usually None or Color.</p></li><li><p>clearColor is the clear color of the resource, Float4 or Int4. depends on clearValueType.</p></li><li><p>clearValueType is the type of the resource&#39;s clear color, Float or Int.</p></li></ul><p>If the resource is marked with a clear color, then the resource content is cleared with clearColor before executing <strong>ComputePass</strong>. Raster type passes(Raster) do not clear <strong>ComputeView</strong> content.</p><h2 id="rendering-view-settings" tabindex="-1">Rendering view settings <a class="header-anchor" href="#rendering-view-settings" aria-label="Permalink to &quot;Rendering view settings&quot;">​</a></h2><p><strong>Raster</strong>：</p><p><img src="'+k+'" width="760"></p><p><strong>Compute</strong>：</p><p><img src="'+d+'" width="760"></p><h2 id="renderqueue" tabindex="-1">RenderQueue <a class="header-anchor" href="#renderqueue" aria-label="Permalink to &quot;RenderQueue&quot;">​</a></h2><p>The <strong>Render Queue</strong> is a child node of the <strong>Render Pass</strong> (Render Pass) and has a strict (rendering) order of precedence. Only after the contents of one <strong>Render Queue</strong> are fully drawn, the contents of the next <strong>Render Queue</strong> will be drawn.</p><p>There are two types of <strong>render queues</strong>: <strong>rasterization queue</strong>, <strong>computation queue</strong>. are added in <strong>rasterization pass</strong> and <strong>computation pass</strong>, respectively.</p><h3 id="rasterqueue" tabindex="-1">RasterQueue <a class="header-anchor" href="#rasterqueue" aria-label="Permalink to &quot;RasterQueue&quot;">​</a></h3><p><strong>Rasterization queue</strong> performs rasterization tasks, typically drawing <strong>scenes</strong>, drawing full-screen quads, etc. <strong>Rasterization queue</strong> is internally drawn in unspecified order.</p><p><img src="'+c+'" width="760"></p><p><img src="'+g+'" width="760"></p><ul><li><p>hint is a queue hint with four options None, Opaque, Cutout, Transparent. hint does not affect execution and is only used for performance testing. For example, on mobile platforms, we often want to draw the Opaque queue first (with AlphaTest off) and then the Cutout queue (with AlphaTest on). If an object with AlphaTest on is accidentally mixed in with the draw content of the Opaque queue, it will degrade the graphics performance. Therefore, we will check if the user&#39;s commit meets the expectation through the queue hint.</p></li><li><p>name is the name displayed during debugging. If it is empty, the system will give the default name.</p></li></ul><h3 id="computequeue" tabindex="-1">ComputeQueue <a class="header-anchor" href="#computequeue" aria-label="Permalink to &quot;ComputeQueue&quot;">​</a></h3><p><strong>Compute Queue</strong> contains only <strong>Dispatch</strong> , executed sequentially.</p><p><img src="'+E+'" width="520"></p><p><img src="'+u+'" width="760"></p><p><strong>Compute Pass</strong> No queue hint.</p><h2 id="rendercontent" tabindex="-1">RenderContent <a class="header-anchor" href="#rendercontent" aria-label="Permalink to &quot;RenderContent&quot;">​</a></h2><p><strong>Rendering content</strong> is sorted by <strong>rendering queue</strong> and consists of multiple elements.</p><h3 id="scene" tabindex="-1">Scene <a class="header-anchor" href="#scene" aria-label="Permalink to &quot;Scene&quot;">​</a></h3><p>2D and 3D <strong>scenes</strong> that need to be drawn. Suitable for <strong>RasterQueue</strong>.</p><p><img src="'+y+'" width="760"></p><p>Can be added via camera or directly. Certain lighting information can be attached.</p><ul><li>sceneFlags controls to some extent the rendering of <strong>scene</strong>. For example, which objects are rendered (Opaque, Cutout, Transparent), whether to render only shadow cast objects (ShadowCaster), whether to render only the UI, the lighting method (None, Default, Volumetirc, Clustered, PlanarShadow), whether to render GeometryRenderer, whether to render Profiler, etc.</li></ul><h3 id="quad" tabindex="-1">Quad <a class="header-anchor" href="#quad" aria-label="Permalink to &quot;Quad&quot;">​</a></h3><p>Full screen / partial <strong>Quad</strong>. Commonly used for post-effects rendering. Suitable for <strong>RasterQueue</strong>.</p><p><img src="'+m+'" width="760"></p><h3 id="dispatch" tabindex="-1">Dispatch <a class="header-anchor" href="#dispatch" aria-label="Permalink to &quot;Dispatch&quot;">​</a></h3><p>Used for <strong>ComputeQueue</strong>.</p><p><img src="'+F+'" width="760"></p><h3 id="dynamic-settings" tabindex="-1">Dynamic Settings <a class="header-anchor" href="#dynamic-settings" aria-label="Permalink to &quot;Dynamic Settings&quot;">​</a></h3><p>We can dynamically set some properties of Queue, Pass.</p><p>For example, viewport, clearRenderTarget, etc.</p><h2 id="rendering-data-settings-under-development" tabindex="-1">Rendering Data Settings(under development) <a class="header-anchor" href="#rendering-data-settings-under-development" aria-label="Permalink to &quot;Rendering Data Settings(under development)&quot;">​</a></h2><p>When writing rendering algorithms, we often need to set up some data for the Shader to use.</p><p>The <strong>RenderGraph</strong> provides interfaces for setting data in <strong>RenderPass</strong>, <strong>RenderQueue</strong>.</p><p><img src="'+f+'" width="760"></p><p>The user can set Constant, Buffer, Texture, and other data.</p><p>This data can be read-only or always in read/write state.</p><p>For resources with read/write state changes, we recommend tracking with <strong>RenderView</strong>.</p><p>Each <strong>RenderPass</strong>, <strong>RenderQueue</strong> has its own separate storage.</p><p>Each node has a different data update/upload frequency. The update frequency of user filled constants, Shader Descriptor (Descriptor) needs to match the update frequency of the node.</p><ul><li><p><strong>Rendering Pass</strong>: one upload per <strong>rendering pass</strong> (PerPass).</p></li><li><p><strong>Rendering Queue</strong>: one upload per <strong>rendering phase</strong> (PerPhase).</p></li></ul><p><img src="'+C+'" width="760"></p><h2 id="feature-enable" tabindex="-1">Feature Enable <a class="header-anchor" href="#feature-enable" aria-label="Permalink to &quot;Feature Enable&quot;">​</a></h2><p>Check the <strong>Custom Rendering Pipeline</strong> in <strong>Project Settings</strong> -&gt; <strong>Feature Cropping</strong>:</p><p><img src="'+w+'" width="760"></p><p>Select a registered <strong>custom rendering pipeline</strong> by filling in the name of the <strong>custom pipeline</strong>.</p><p><strong>Forward Render Pipeline</strong> (named Custom or Forward) and <strong>Backward Render Pipeline</strong> (name Deferred) are currently supported.</p><p><img src="'+D+`" width="760"></p><h2 id="write-a-custom-render-pipeline" tabindex="-1">Write a Custom Render Pipeline <a class="header-anchor" href="#write-a-custom-render-pipeline" aria-label="Permalink to &quot;Write a Custom Render Pipeline&quot;">​</a></h2><p>Create a new TypeScript file, define a class named TestCustomPipeline, have it implement the <code>rendering.PipelineBuilder</code> interface, and register the pipeline to the system via the <code>rendering.setCustomPipeline</code> method, as shown in the following code.</p><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { _decorator, rendering, renderer, game, Game } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;cc&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { AntiAliasing, buildForwardPass, buildBloomPasses,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    buildFxaaPass, buildPostprocessPass, buildUIPass, isUICamera, decideProfilerCamera } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;./PassUtils&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> TestCustomPipeline</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> implements</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> rendering</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">PipelineBuilder</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    setup</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">cameras</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> renderer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">scene</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Camera</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[], </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">pipeline</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> rendering</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Pipeline</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> void</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        decideProfilerCamera</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(cameras);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> cameras.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> camera</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> cameras[i];</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (camera.scene </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">                continue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> isGameView</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> camera.cameraUsage </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> renderer.scene.CameraUsage.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">GAME</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">                ||</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> camera.cameraUsage </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> renderer.scene.CameraUsage.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">GAME_VIEW</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">isGameView) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">                // forward pass</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">                buildForwardPass</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(camera, pipeline, isGameView);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">                continue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            }</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">            // TODO: The actual project is not so simple to determine whether the ui camera, here is just as a demo demonstration.</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">isUICamera</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(camera)) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">                // forward pass</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">                const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> forwardInfo</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> buildForwardPass</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(camera, pipeline, isGameView);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">                // fxaa pass</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">                const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> fxaaInfo</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> buildFxaaPass</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(camera, pipeline, forwardInfo.rtName);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">                // bloom passes</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">                const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> bloomInfo</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> buildBloomPasses</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(camera, pipeline, fxaaInfo.rtName);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">                // Present Pass</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">                buildPostprocessPass</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(camera, pipeline, bloomInfo.rtName, AntiAliasing.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">NONE</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">                continue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            }</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">            // render ui</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">            buildUIPass</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(camera, pipeline);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">game.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">on</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Game.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">EVENT_RENDERER_INITED</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    rendering.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setCustomPipeline</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Test&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">new</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> TestCustomPipeline);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre></div><p>You can see that the above code references the PassUtils script file, which facilitates direct use by users by simply encapsulating the logic associated with the commonly used <code>RenderPass</code> (PassUtils can be found here <a href="./code/PassUtils.ts">download</a>).</p><p>PassUtils has quite a few functions, and we take some of the logic of <code>buildPostprocessPass</code> to introduce.</p><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> buildPostprocessPass</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">camera</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">    ppl</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">    inputTex</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> string</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">    antiAliasing</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> AntiAliasing</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> AntiAliasing.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">NONE</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // ...</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> postprocessPassRTName</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> \`postprocessPassRTName\${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">cameraID</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}\`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> postprocessPassDS</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> \`postprocessPassDS\${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">cameraID</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}\`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ppl.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">containsResource</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(postprocessPassRTName)) {        </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // Register a color texture resource, because current pass is to be on-screen, so pass camera.windows as an on-screen information. If is off-screen, you can use &#39;ppl.addRenderTarget&#39; instead.</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        ppl.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">addRenderTexture</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(postprocessPassRTName, Format.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">BGRA8</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, width, height, camera.window);        </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // Register a depthStencil texture resource</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        ppl.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">addDepthStencil</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(postprocessPassDS, Format.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">DEPTH_STENCIL</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, width, height, ResourceResidency.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">MANAGED</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }    </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // The follows codes will update the registered information of the color texture and depth stencil texture (mainly for the size), also if is off-screen, use &#39;ppl.updateRenderTarget&#39; instead</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ppl.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">updateRenderWindow</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(postprocessPassRTName, camera.window);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ppl.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">updateDepthStencil</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(postprocessPassDS, width, height);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // Register a RasterPass with a layoutName of post-process</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> postprocessPass</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ppl.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">addRasterPass</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(width, height, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;post-process&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    postprocessPass.name </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> \`CameraPostprocessPass\${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">cameraID</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}\`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;    </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // Set the viewport information of current rasterPass</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    postprocessPass.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setViewport</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Viewport</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(area.x, area.y, area.width, area.height));</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // Determine if there is information of the same name of the input texture in the system, and inject the input texture into the sampler of outputResultMap</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (ppl.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">containsResource</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(inputTex)) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> computeView</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ComputeView</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        computeView.name </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;outputResultMap&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        postprocessPass.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">addComputeView</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(inputTex, computeView);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }    </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // Config the clear color of the postprocessPass的clear</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> postClearColor</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Color</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, camera.clearColor.w);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (camera.clearFlag </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ClearFlagBit.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">COLOR</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        postClearColor.x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> camera.clearColor.x;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        postClearColor.y </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> camera.clearColor.y;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        postClearColor.z </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> camera.clearColor.z;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // Register for color texture related passes to view</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> postprocessPassView</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> RasterView</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;_&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        AccessType.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">WRITE</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, AttachmentType.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">RENDER_TARGET</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        getLoadOpOfClearFlag</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(camera.clearFlag, AttachmentType.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">RENDER_TARGET</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">),</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        StoreOp.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">STORE</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        camera.clearFlag,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        postClearColor);    </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // Register a PassView for depth stencil texture</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> postprocessPassDSView</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> RasterView</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;_&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        AccessType.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">WRITE</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, AttachmentType.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">DEPTH_STENCIL</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        getLoadOpOfClearFlag</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(camera.clearFlag, AttachmentType.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">DEPTH_STENCIL</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">),</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        StoreOp.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">STORE</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        camera.clearFlag,</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Color</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(camera.clearDepth, camera.clearStencil, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">));</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // Associate the color texture resource with the associated pass view (i.e. the color texture output of the renderpass)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    postprocessPass.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">addRasterView</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(postprocessPassRTName, postprocessPassView);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // Associate the depth stencil texture resource with the associated pass view</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    postprocessPass.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">addRasterView</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(postprocessPassDS, postprocessPassDSView);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // Add a specific render queue and get the postprocess material to draw a quadrilateral of equal size to the screen</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    postprocessPass.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">addQueue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(QueueHint.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">NONE</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">addFullscreenQuad</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        postInfo.postMaterial, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, SceneFlags.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">NONE</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    );</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // ...</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (profilerCamera </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> camera) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // Enable profiler</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        postprocessPass.showStatistics </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // Return the resources of color texture and depth stencil texture, which can be used as data source for other render passes</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { rtName: postprocessPassRTName, dsName: postprocessPassDS };</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>First we need to know how <code>RasterPass</code> configures <code>layoutName</code> (i.e. the post-process string in the above code). After opening the <code>post-process.effect</code> file, we can see that the <code>pass</code> name defined internally is <code>post-process</code>, so the pass name in the effect file is used as the <code>layoutName</code> of RasterPass. If effect does not define pass name, then <code>layoutName</code> of <code>RasterPass</code> has to be assigned to <code>default</code> (forward/gbuffer related RasterPass are configured by default). So to configure your own post-processing scheme, you need to configure the pass name correctly for the effect file you write.</p><p><img src="`+P+'" width="760"></p><p>We also need to use the output texture of the previous pass as the input information of the current pass, as mentioned above, we need to achieve this through <code>ComputeView</code>, and here the name of <code>ComputeView</code> is set to <code>outputResultMap</code>, so how to configure this name correctly? Continuing the analysis of the <code>post-process.effect</code> file, we can see the following code, the name of <code>ComputeView</code> is the same as the texture input name of the slice shader of <code>post-process-fs</code>.</p><p><img src="'+b+'" width="760"></p><p>We also need to declare the outputResultMap name with the following line of code, indicating that the input texture is used at Pass level.</p><div class="language-glsl vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">glsl</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#pragma</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> rate</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> outputResultMap</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> pass</span></span></code></pre></div><p>After defining <code>TestCustomPipeline</code>, you need to introduce this file through other logical code (e.g. components, etc.) in order to activate the <code>Game.EVENT_RENDERER_INITED</code> event listener, and then change <strong>Project Settings</strong> -&gt; <strong>Macro Configurations</strong> -&gt; <strong>CUSTOM_PIPELINE_NAME</strong> to <code>Test</code> :</p><p><img src="'+A+'" width="760"></p><p>The result after running is shown below, which contains the after-effects of fxaa and bloom.</p><p><img src="'+R+'" width="760"></p><p>This is the general process of defining a <code>RenderPass</code>. PassUtils also defines other Passes that users can refer to, including <code>BloomPasses</code>, <code>FxaaPass</code> and so on. These <code>RenderPasses</code> provide parameters to adjust the output (e.g. Bloom exposure intensity, number of iterations, etc.), so users can try it out for themselves.</p>',121),q=[_];function T(v,x,S,N,I,V){return e(),i("div",null,q)}const Q=s(B,[["render",T]]);export{O as __pageData,Q as default};
