import{_ as s,c as a,o as i,a5 as n}from"./chunks/framework.CqnjdYks.js";const e="/docs/cocos/assets/create-chunk.BhGR3gzo.png",t="/docs/cocos/assets/new-chunk.CEJ0VyQP.png",_=JSON.parse('{"title":"着色器片段（Chunk）","description":"","frontmatter":{},"headers":[],"relativePath":"zh/manual/shader/effect-chunk-index.md","filePath":"zh/manual/shader/effect-chunk-index.md"}'),l={name:"zh/manual/shader/effect-chunk-index.md"},h=n('<h1 id="着色器片段-chunk" tabindex="-1">着色器片段（Chunk） <a class="header-anchor" href="#着色器片段-chunk" aria-label="Permalink to &quot;着色器片段（Chunk）&quot;">​</a></h1><p>着色器片段（Chunk）是一种跨文件代码引用机制，使着色器代码片段可以在不同的文件之间进行复用。</p><p>着色器片段的语法基于 <strong>GLSL 300 ES</strong>，在资源加载时会进行预编译，生成目标 Shader 代码。</p><h2 id="创建着色器片段" tabindex="-1">创建着色器片段 <a class="header-anchor" href="#创建着色器片段" aria-label="Permalink to &quot;创建着色器片段&quot;">​</a></h2><p>在 <strong>资源管理器</strong> 面板中点击右键，选择 <strong>创建 -&gt; 着色器片段（Chunk）</strong>：</p><p><img src="'+e+'" alt="创建着色器片段"></p><p>便可创建一个默认名为 <strong>chunk</strong> 的着色器片段，如下图：</p><p><img src="'+t+`" alt="片段模板"></p><h2 id="include-机制" tabindex="-1">Include 机制 <a class="header-anchor" href="#include-机制" aria-label="Permalink to &quot;Include 机制&quot;">​</a></h2><p>在标准 GLSL 语法基础上，Cocos Shader 引入了 C 语言风格的语法扩展 — Include 机制。</p><p>通过 include 机制，可以在任意 Shader 代码（CCProgram 块或独立的头文件）中引入其他代码片段，如下所示：</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 引入引擎内置着色器片段</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#include</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &lt;builtin/uniforms/cc-global&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 引入自定义着色器片段</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#include</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;../headers/my-shading-algorithm.chunk&quot;</span></span></code></pre></div><p>相关规则和注意事项：</p><ul><li><p>着色器片段的扩展名默认为 <code>.chunk</code>，在 include 时可忽略。引入其他代码片段时可使用双括号或者尖括号，二者无区别，例如：</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#include</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;filename.chunk&quot;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#include</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;filename&quot;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 可忽略扩展名</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#include</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &lt;filename.chunk&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#include</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &lt;filename&gt;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 可忽略扩展名</span></span></code></pre></div></li><li><p>在 Cocos Shader 编译时着色器片段会被展开，且只会展开一次。因此书写时不用担心，每个模块都可以包含自己依赖的着色器片段，即使这中间有重复；</p></li><li><p>所有不参与运行时实际计算流程的函数声明会在编译时被剔除，因此可以放心包含各类工具函数，不用担心生成的目标代码会有冗余；</p></li><li><p>着色器片段引用可以指定基于当前文件目录的相对路径（以下统称“相对路径”），也可以指定基于编辑器 <strong>资源管理器</strong> 面板中 <strong>internal -&gt; chunks</strong> 目录的相对路径（以下统称“项目绝对路径”）。两个目录下如果有同名文件，则后者（项目绝对路径）优先；</p></li><li><p>Cocos Creator 提供了一些内置着色器片段资源，主要包括一些常用的工具函数和标准光照模型等，位于 <a href="./../editor/assets/">资源管理器</a> 面板中的内置资源数据库（简称 DB）<code>internal</code> 的 <code>chunks</code> 目录下，因此可以不加目录直接引用。</p></li><li><p>引用了编辑器其他 DB（Database）的着色器片段只能指定项目绝对路径。当多个 DB 在此路径下有相同文件时，DB 优先级为：用户项目 DB &gt; 插件 DB &gt; Internal DB；</p></li><li><p>所有在同一个 Cocos Shader 文件中声明的 CCProgram 代码块都可以相互引用。</p></li></ul>`,14),p=[h];function c(o,r,d,k,u,g){return i(),a("div",null,p)}const C=s(l,[["render",c]]);export{_ as __pageData,C as default};
