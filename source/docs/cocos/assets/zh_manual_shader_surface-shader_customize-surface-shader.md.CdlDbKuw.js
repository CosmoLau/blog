import{_ as n,E as t,c as e,m as s,a,J as l,w as h,a5 as r,o as p}from"./chunks/framework.CqnjdYks.js";const C=JSON.parse('{"title":"自定义表面着色器","description":"","frontmatter":{},"headers":[],"relativePath":"zh/manual/shader/surface-shader/customize-surface-shader.md","filePath":"zh/manual/shader/surface-shader/customize-surface-shader.md"}'),d={name:"zh/manual/shader/surface-shader/customize-surface-shader.md"},o=r(`<h1 id="自定义表面着色器" tabindex="-1">自定义表面着色器 <a class="header-anchor" href="#自定义表面着色器" aria-label="Permalink to &quot;自定义表面着色器&quot;">​</a></h1><p>虽然 Surface Shader 提供了大多数场景材质都能适配的光照模型，但其功能还是较为固定的。</p><p>有时候，<strong>用户需要使用完全定制化的光照计算和色彩计算</strong>，比如说：一些特殊的、风格化的材质，需要轮廓光、额外的补光、非真实的环境照明等等。</p><p>针对这类极为特殊的情况，Surface Shader 也提供了自定义能力。</p><p>但需要注意的是，由于干预了表面材质数据和光照计算过程，渲染效果可能会出现意料之外的效果。</p><h2 id="_1、自定义-vs-输出与-fs-输入" tabindex="-1">1、自定义 VS 输出与 FS 输入 <a class="header-anchor" href="#_1、自定义-vs-输出与-fs-输入" aria-label="Permalink to &quot;1、自定义 VS 输出与 FS 输入&quot;">​</a></h2><p>我们可以在 VS 阶段新定义一个传递变量之后，在某个 Surface 函数中计算并输出该变量值。</p><p>在 FS 阶段定义一个同名变量之后在某个 Surface 函数中获取并使用该变量值。</p><p>详情请参考 <a href="./fs-input.html">Fragment Shader 的输入参数</a>：<strong>自定义传递值</strong>。</p><h2 id="_2、自定义材质信息" tabindex="-1">2、自定义材质信息 <a class="header-anchor" href="#_2、自定义材质信息" aria-label="Permalink to &quot;2、自定义材质信息&quot;">​</a></h2><p>在 VS 函数块中添加如下代码：</p><div class="language-glsl vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">glsl</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//PBR 光照模型</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#include</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &lt;surfaces/data-structures/standard&gt;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// toon 光照模型</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//#include &lt;surfaces/data-structures/toon&gt; </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#define</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> CC_SURFACES_FRAGMENT_MODIFY_SHARED_DATA</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> SurfacesFragmentModifySharedData</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(inout SurfacesMaterialData </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">surfaceData</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // set user-defined data to surfaceData</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>函数开头的 <code>#include</code> 用于决定使用的<strong>材质数据结构名称</strong>，根据不同的 include 文件, 会采用不同的 <code>SurfacesMaterialData</code> 结构体。</p><p>具体内容，可以查看 <strong>internal/chunks/surfaces/data-structures/</strong> 目录下的 <strong>standard.chunk</strong> 和 <strong>toon.chunk</strong></p><p>当定义了 <code>CC_SURFACES_FRAGMENT_MODIFY_SHARED_DATA</code> 宏后，Shader编译器会选择你自己写的 <code>SurfacesFragmentModifySharedData</code> 来替换默认的函数。</p><p>此函数会在 vs 阶段被调用，具体可以查看 <strong>internal/chunks/shading-entries/main-functions/</strong> 目录下的： <strong>render-to-scene/vs.chunk</strong> 和 <strong>render-to-shadowmap/vs.chunk</strong> 文件。</p><p>在这个函数中，我们可以直接修改 surfaceData 里的属性，为光照阶段做准备。</p><h2 id="自定义光照计算结果" tabindex="-1">自定义光照计算结果 <a class="header-anchor" href="#自定义光照计算结果" aria-label="Permalink to &quot;自定义光照计算结果&quot;">​</a></h2><p>有了上面自定义的 SurfacesMaterialData，我们还需要配合光照阶段，才能实现我们想要的计算效果。</p><p>在 FS 中，添加下面的代码：</p><div class="language-glsl vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">glsl</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#include</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &lt;lighting-models/includes/common&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#define</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> CC_SURFACES_LIGHTING_MODIFY_FINAL_RESULT</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> SurfacesLightingModifyFinalResult</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(inout LightingResult </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">result</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, in LightingIntermediateData </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">lightingData</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, in SurfacesMaterialData </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">surfaceData</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, in LightingMiscData </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">miscData</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // use surfaceData and lightingData for customizing lighting result</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>这个函数会在 fs.chunk 中被调用。</p><p>可以看到函数有四个参数：</p><ul><li>LightingIntermediateData：计算光照时需要的信息，如法线、视线方向、视距等等</li><li>SurfacesMaterialData：颜色、世界空间法线、PBR参数等信息</li><li>LightingMiscData：光源类型、位置、方向、颜色、强度等</li><li>LightingResult：用于返回光照结果，如 diffuse, specular, shadow,ao 等等。</li></ul><p>在这个函数中，可以利用光照和材质参数，计算出光照结果，并放入 result 中。</p><p>对于局部光源（点光、聚光灯等）而言，此函数会逐光源执行。也就是说，如果物体受 6 个光源影响，这个函数会被调用 6 次。</p>`,26),c=s("p",null,"比如，如果想要在函数中使用 PBR 光照模型内置的光照函数，可以包含 lighting-models/includes/standard 头文件。",-1),k=s("p",null,"在这个头文件中，会包含 lighting-models/model-functions/standard 头文件。",-1),g=s("p",null,"PBR光照相关的内置函数都在这里，直接调用即可。",-1),u=s("h2",{id:"更多自定义",tabindex:"-1"},[a("更多自定义 "),s("a",{class:"header-anchor",href:"#更多自定义","aria-label":'Permalink to "更多自定义"'},"​")],-1),E=s("p",null,"如果上面的自定义机制还不能满足需求，建议参考 chunks/shading-entries 构建自己的 main 函数，以控制整个着色流程和计算细节。",-1);function f(_,m,F,D,S,y){const i=t("font");return p(),e("div",null,[o,s("p",null,[a("如果希望 "),l(i,{color:"#ff0000"},{default:h(()=>[a("在重载函数内可以直接调用现成的内置光照模块函数")]),_:1}),a("，可以将 lighting-models/includes/common 改为对应光照模型使用的头文件。")]),c,k,g,u,E])}const v=n(d,[["render",f]]);export{C as __pageData,v as default};
