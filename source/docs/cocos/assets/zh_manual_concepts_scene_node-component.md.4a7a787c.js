import{_ as e,v as o,b as r,R as t}from"./chunks/framework.5ffcbaff.js";const s="/docs/cocos/assets/nodes.c031949e.jpg",a="/docs/cocos/assets/create.1f2edcbf.png",n="/docs/cocos/assets/node-property.4734ca06.png",c="/docs/cocos/assets/mobility.fd5a8559.png",i="/docs/cocos/assets/inspector.ea64f820.png",p="/docs/cocos/assets/node-before.5919001b.png",l="/docs/cocos/assets/node-after.0921d5f2.png",d="/docs/cocos/assets/node-chart.bd7ee840.png",h="/docs/cocos/assets/directional-light.59c87709.png",g="/docs/cocos/assets/node-layer-gizmo.696c567e.png",m="/docs/cocos/assets/node-layer-edit.bdb81e7c.png",P=JSON.parse('{"title":"节点和组件","description":"","frontmatter":{},"headers":[],"relativePath":"zh/manual/concepts/scene/node-component.md","filePath":"zh/manual/concepts/scene/node-component.md"}'),b={name:"zh/manual/concepts/scene/node-component.md"},u=t('<h1 id="节点和组件" tabindex="-1">节点和组件 <a class="header-anchor" href="#节点和组件" aria-label="Permalink to &quot;节点和组件&quot;">​</a></h1><p>Cocos Creator 3.0 的工作流程是以组件式开发为核心的，组件式架构也称作 <strong>实体 — 组件架构</strong>（Entity-Component System），简单来说，就是以组合而非继承的方式进行游戏中各种元素的构建。</p><p>在 Cocos Creator 3.0 中，<strong>节点（Node）</strong> 是承载组件的实体，我们通过将具有各种功能的 <strong>组件（Component）</strong> 挂载到节点上，来让节点具有各式各样的表现和功能。接下来我们看看如何在场景中创建节点和添加组件。</p><h2 id="节点" tabindex="-1">节点 <a class="header-anchor" href="#节点" aria-label="Permalink to &quot;节点&quot;">​</a></h2><p>节点是场景的基础组成单位。节点之间是树状的组织关系，每个节点可以有多个子节点：</p><p><img src="'+s+'" alt="nodes"></p><p>节点具有以下特性：</p><ul><li>节点包含一组基础属性（位移、旋转、缩放），节点之间通过一组相对变换关系组织在一起，详情可参考 <a href="./coord.html">坐标系和变换</a>。</li><li>节点间的更新顺序是逐级更新的。子节点的更新依赖于父节点，子节点跟随父节点变换</li><li>节点上可以添加组件，将多个组件与节点关联在一起</li></ul><h3 id="创建节点-node" tabindex="-1">创建节点（Node） <a class="header-anchor" href="#创建节点-node" aria-label="Permalink to &quot;创建节点（Node）&quot;">​</a></h3><p>要最快速地获得一个具有特定功能的节点，可以通过 <strong>层级管理器</strong> 左上角的 <strong>创建节点</strong> 按钮。我们以创建一个最简单的 Sphere（球体）节点为例，点击左上角的 <strong>+</strong> 创建节点按钮，然后选择 <strong>创建 3D 对象 -&gt; 创建 Sphere 球体</strong>：</p><p><img src="'+a+'" alt="create"></p><p>之后我们就可以在 <strong>场景编辑器</strong> 和 <strong>层级管理器</strong> 中看到新添加的 Sphere 节点了。新节点命名默认为 <code>Sphere</code>，表示这是一个主要由 Sphere 组件负责提供功能的节点。您也可以尝试再次点击 <strong>创建节点</strong> 按钮，选择其他的节点类型，可以看到它们的命名和表现会有所不同。需要注意的是：创建 UI 节点时会自动创建一个 Canvas 节点作为 UI 节点的根节点，具体内容可参考文档 <a href="./../../2d-object/ui-system/">UI 结构说明</a>。</p><p>更多关于节点在层级管理器中的单选、多选、复制、删除等操作，可参考 <a href="./../../editor/hierarchy/">层级管理器</a>。</p><p>若要在脚本中动态创建节点，可参考文档 <a href="./../../scripting/create-destroy.html">创建和销毁节点</a>。</p><h2 id="属性" tabindex="-1">属性 <a class="header-anchor" href="#属性" aria-label="Permalink to &quot;属性&quot;">​</a></h2><p><img src="'+n+'" alt="property"></p><p>节点除了记录其位置、旋转、缩放外还拥有 Mobility 以及 Layer 属性。</p><ul><li><p><strong>Mobility</strong>：节点的可移动性。不同的可移动性会导致节点在光照上有不同的特性和表现</p><p><img src="'+c+'" alt="mobility"></p><p>对于含有光源组件的节点，Mobility 的表现略有不同，分别说明如下：</p><ul><li>对于持有光源组件的节点 <ul><li>Static 静态光源：会烘焙直接光与间接光，烘焙完运行时不参与计算</li><li>Stationary 固定光源：只烘焙间接光，只在运行时计算直接光</li><li>Movable 可移动光源：不参与烘焙，只在运行时计算直接光</li></ul></li><li>对于持有 MeshRenderer 的节点 <ul><li>Static &amp; Stationary 静态物体：可使用光照贴图</li><li>Movable 动态物体：可使用光照探针 通常来说在拥有 MeshRenderer 组件的节点上可以添加灯光组件，但并不建议，可以考虑分开多个节点来实现这样的需求。</li></ul></li></ul></li><li><p><strong>Layer</strong>：设定节点的可见性能力。请参考下方 <strong>设置节点的 Layer 属性</strong> 文档。</p></li></ul><h2 id="组件" tabindex="-1">组件 <a class="header-anchor" href="#组件" aria-label="Permalink to &quot;组件&quot;">​</a></h2><p>我们刚刚创建了节点，现在我们来看看什么是组件，以及组件和节点的关系。<br> 选中我们刚才创建的 <code>Sphere</code> 节点，可以看到 <strong>属性检查器</strong> 中的显示：</p><p><img src="'+i+'" alt="Properties"></p><p><strong>属性检查器</strong> 中以 <code>Node</code> 标题开始的部分就是节点的属性，节点属性包括了节点的位置、旋转、缩放等变换信息。我们将在 <a href="./coord.html">坐标系和节点属性变换</a> 部分进行详细介绍。</p><p>接下来以 <code>cc.MeshRenderer</code> 标题开始的部分就是 Sphere 上挂载的 MeshRenderer 组件的属性。在 Creator 中，MeshRenderer 组件用于渲染静态的 3D 模型，其中的 <code>Mesh</code> 属性用于指定渲染所用的网格资源。因为我们刚刚创建的是 Sphere 节点，所以这里默认是 <code>sphere.mesh</code>。<br> 而 <code>Materials</code> 属性用于指定渲染所用的 <a href="./../../asset/material.html">材质资源</a>，你可以尝试从 <strong>资源管理器</strong> 中拖拽任意一个材质到 <strong>属性检查器</strong> 的 <code>Materials</code> 属性中，可以看到刚才默认的材质变成了指定的材质。</p><blockquote><p>组件上设置好的任何资源，比如这里的 <code>sphere.mesh</code>，都会在场景加载时自动同时加载好。你也可以在自定义的组件中声明需要设置和自动加载的资源类型，详见 <a href="./../../scripting/load-assets.html">获取和加载资源</a>。</p></blockquote><p>除了在编辑器中手动添加组件，还可以通过脚本来控制组件，详情请参考 <a href="./../../scripting/component.html">组件的创建和销毁</a>。</p><h3 id="节点属性对组件的影响" tabindex="-1">节点属性对组件的影响 <a class="header-anchor" href="#节点属性对组件的影响" aria-label="Permalink to &quot;节点属性对组件的影响&quot;">​</a></h3><p>节点和 MeshRenderer 组件进行组合之后，就可以通过修改节点属性来控制对网格资源的渲染，您可以按照下图中红线标记属性的设置对您的节点进行调整，可以看到模型的旋转和缩放都发生了变化。</p><p><strong>调整前</strong>：</p><p><img src="'+p+'" alt="node property"></p><p><strong>调整后</strong>：</p><p><img src="'+l+'" alt="node property"></p><p>我们前面提到了组件式的结构是以组合方式来实现功能的扩展，节点和 MeshRenderer 组件的组合如下图所示：</p><p><img src="'+d+'" alt="node component relationship"></p><h2 id="添加其他组件" tabindex="-1">添加其他组件 <a class="header-anchor" href="#添加其他组件" aria-label="Permalink to &quot;添加其他组件&quot;">​</a></h2><p>在一个节点上可以添加多个组件，来为节点添加更多功能。举个例子：</p><p>我们可以在上面的例子中继续选中 <code>Sphere</code> 这个节点，然后点击 <strong>属性检查器</strong> 最下方的 <strong>添加组件</strong> 按钮，选择 <strong>Light -&gt; DirectionalLight</strong> 来添加一个 <strong>平行光</strong> 组件。</p><p>之后对 <strong>平行光</strong> 组件的属性进行设置，例如将平行光的 <code>Color</code> 属性调整为红色，可以看到球体模型的颜色发生了变化，也就是我们为节点添加的 DirectionalLight 组件生效了！</p><p><img src="'+h+'" alt="button property"></p><blockquote><p>这里只是简单举个效果较为明显的例子，使用中并不建议在 sphere 节点上添加 DirectionalLight 组件。</p></blockquote><h2 id="设置节点的可见性" tabindex="-1">设置节点的可见性 <a class="header-anchor" href="#设置节点的可见性" aria-label="Permalink to &quot;设置节点的可见性&quot;">​</a></h2><p>引擎采用更加通用的节点，和相机相匹配。当节点设置的 Layer 属性包含在相机的 <a href="./../../editor/components/camera-component.html">Visibility 属性</a> 中时，节点便可以被相机看见，同时支持 3D 组件与 2D 组件的混合渲染。以便更灵活地控制节点组件的可见性，使分组显示多样化。</p><h3 id="设置节点的-layer-属性" tabindex="-1">设置节点的 Layer 属性 <a class="header-anchor" href="#设置节点的-layer-属性" aria-label="Permalink to &quot;设置节点的 Layer 属性&quot;">​</a></h3><p><img src="'+g+'" alt="node layer gizmo"></p><p>节点的 Layer 属性是全局且唯一的，但是不同的节点可以设置相同的 Layer 属性，使其被同一个相机所观察。开发者可以使用引擎内置的 Layer 属性，也可以使用自定义的 Layer 属性，点击下图中的 <strong>Edit</strong> 按钮即可前往 <strong>项目设置 -&gt; Layers</strong> 页面进行设置。详情请参考 <a href="./layer.html">层级</a> 文档。</p><p><img src="'+m+'" alt="layer edit"></p><p>其中 <code>User Layer 0</code> - <code>User Layer 19</code> 是提供给用户自定义设置的 layer 属性，用户只需要在 layer 后面填入自定义 layer name 就可以启用这个 layer 属性，并在节点上编辑。</p><h2 id="小结" tabindex="-1">小结 <a class="header-anchor" href="#小结" aria-label="Permalink to &quot;小结&quot;">​</a></h2><p>上面的例子中，我们先是将 MeshRenderer 组件和节点组合，有了可以指定渲染材质的网格资源，接下来我们通过修改节点属性，能够对这个模型进行缩放和旋转等不同方式的显示。现在我们又为这个节点添加了 DirectionalLight 组件，让节点可以根据平行光源的不同状态展现不同的效果。这就是 Cocos Creator 3.0 组件式开发的工作流程，我们可以用这样的方式将不同的功能组合在一个节点上，实现更多复杂目标。</p><p>需要注意的是，一个节点上只能添加一个渲染组件，渲染组件包括 <strong>MeshRenderer</strong>、<strong>Sprite</strong>、<strong>Label</strong>、<strong>Graphics</strong>、<strong>Mask</strong>、<strong>RichText</strong>、<strong>UIStaticBatch</strong> 等。</p>',49),y=[u];function _(f,q,L,M,S,k){return o(),r("div",null,y)}const C=e(b,[["render",_]]);export{P as __pageData,C as default};
