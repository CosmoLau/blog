import{_ as e,c as t,o,a4 as i}from"./chunks/framework.uQk9_EO2.js";const a="/docs/cocos/assets/composite-shape.7lAYOWfz.jpg",s="/docs/cocos/assets/bow-pulling.D4ssuicO.gif",n="/docs/cocos/assets/recycle-area.C1B_SElK.jpg",r="/docs/cocos/assets/arm.Cywapq5U.jpg",c="/docs/cocos/assets/config.CgFxnqwk.jpg",h="/docs/cocos/assets/arm-apple.BfQOGZjR.gif",l="/docs/cocos/assets/set-step.ducgttYM.gif",p="/docs/cocos/assets/convex.BgXcZsZ2.jpg",k=JSON.parse('{"title":"Physics Examples","description":"","frontmatter":{},"headers":[],"relativePath":"en/physics/physics-example.md","filePath":"en/physics/physics-example.md","lastUpdated":1712305443000}'),d={name:"en/physics/physics-example.md"},m=i('<h1 id="physics-examples" tabindex="-1">Physics Examples <a class="header-anchor" href="#physics-examples" aria-label="Permalink to &quot;Physics Examples&quot;">​</a></h1><h2 id="archery-case" tabindex="-1">Archery Case <a class="header-anchor" href="#archery-case" aria-label="Permalink to &quot;Archery Case&quot;">​</a></h2><ol><li><p>Combining crosses with base shapes - composite shapes</p><p>In the following figure, a cross is combined with two box shapes, and all the colliding bodies on the node are combined into a cross shape, which is the most basic way to achieve a shape with a concave surface.</p><p><img src="'+a+'" alt="composite-shape"></p><p>The easy misuse is to add collision bodies to multiple nodes to put together the cross, hoping that it can keep the overall structure in motion after the collision, which is not possible in the current structure and can only be achieved by adding collision bodies to individual nodes.</p></li><li><p>Shooting and recovering arrows - kinematics, dynamics, events</p><p>The first step of archery is to draw the bow, and the arrow needs to follow the elastic rope skeleton completely, so we don&#39;t want the arrow to be affected by the physical rules.</p><p><img src="'+s+'" alt="bow-pulling"></p><p>The general process of recovering an arrow is to restore it to the bow once it has touched the trigger area after it has been shot. This can be achieved by creating a listening area, first by piecing together the area using the collider component and checking <code>IsTrigger</code> on the collider (the ground in the image below, the part circled in blue, is the listening area).</p><p><img src="'+n+'" alt="recycle-area"></p><p>The above error-prone areas are:</p><ol><li><p>You want to modify the transformation information to manipulate the dynamics (Dynamic) type of rigid body motion, which should be controlled by the values of the physical layer such as velocity, force or impulse.</p></li><li><p>Using a static rigid body to listen for events, a static rigid body will only generate events with a rigid body of type Kinematic or Dynamic. If both are static, no events will be generated.</p></li><li><p>Listen for events with only OnTriggerEnter, but mistakenly think that OnTriggerStay and OnTriggerExit are included.</p></li></ol></li><li><p>Aiming - collision matrix (filter detection), raycast detection, static plane</p><p>Aiming is the step before shooting an arrow. The collimator is on the ray where the arrow is pointing, a static plane collider is added in front of the cross, and then the position of the collimator can be obtained using raycast detection.</p><p><img src="'+r+'" alt="arm"></p><p>The static plane is only used for raycast detection, creating a grouping specifically for it and not with objects such as arrows, apples, etc. This is the most general method of performance optimization.</p><p><img src="'+c+'" alt="config"></p><p>When calling the raycast detection method, set the incoming mask to only and static plane detection, i.e. <code>0b10</code> (binary representation).</p><p>The above-mentioned error-prone areas are:</p><ol><li><p>Not being able to distinguish between groupings on rigid components and layers on nodes. The two concepts are similar, but the users are different, the user of the grouping is the physical module and the user of the layer is the rendering module.</p></li><li><p>Not understanding the mask properly and not knowing what value to pass. Here is a little trick, to a mask that can filter out <code>Others</code> for example, first Others index value is 2, then just let the binary mask from right to left order of the <code>2</code> bit for <code>1</code>, you can let <code>Others</code> through the filter, that is <code>ob100</code> (here it is strongly recommended not to change the index of the grouping arbitrarily).</p></li><li><p>Mistakenly assume that the return value of the raycast detection interface is the hit data. There is a dedicated interface for getting the result, which is designed here to emphasize that this is a reused object. To reduce garbage memory, each call to the interface will only update their data, rather than regenerate a new one (if a persistent record is needed, then a copy can be cloned).</p></li></ol></li><li><p>Shooting apples - static grid, convex package, multi-step simulation (step size adjustment)</p><p>The average apple comes with a concave surface, and dealing with a good concave class or a model with continuous smooth irregular surfaces are very tricky, this is because the current mature theory and techniques are built on top of the world of discrete, convex packages (differential approximation in calculus to represent the differential is the most typical example).</p><p>In real-time physics engines, such objects can only be supported up to the rigid body level of static or kinematic types, and there is nothing that can be done about dynamics. Unfortunately, however, real apple motion is strongly dependent on dynamics, and in this case the only way to participate in the simulation is to fill the apple with a mesh collider in the form of a convex package (with convex checked) and a dynamic rigid body, using an approximation.</p><p><img src="'+h+'" alt="arm-apple"></p><p>The motion performance is very much related to the simulation parameters, and penetration is the most representative phenomenon, which can be achieved by reducing the step length and increasing the number of steps, with a little trick to adjust the step length: enter the fractional equation, <code>1/Frame</code>, where <code>Frame</code> represents the frame rate.</p><p><img src="'+l+'" alt="set-step"></p><p>The above mistakes can be easily made by:</p><ol><li><p>Dynamic rigid bodies added to a mesh collider with <code>convex</code> unchecked are penetrating with other objects or not reacting at all, this is a typical misuse, only those with <code>convex</code> checked will support dynamic rigid bodies.</p></li><li><p>Turning on <code>convex</code> for a model with a very large number of vertices will increase the number of faces of the convex packet, which has a great impact on the performance, and it is not necessary to have a convex packet with a large number of faces.</p></li><li><p>It is normal that the contact at the concave side of the model does not fit well after opening the convex packet, which is now solved by the real-time technique of combining the model with multiple convex packets, as shown in the following figure.</p><p><img src="'+p+'" alt="set-step"></p></li><li><p>Only the step length is adjusted, but not the number of steps, both of which need to work with each other to be effective. The tip is that the number of steps can be set to a larger value at will, and the step length is adjusted according to the maximum speed value; the larger the value, the smaller the step length should be.</p></li></ol></li></ol>',3),g=[m];function u(f,y,b,w,v,_){return o(),t("div",null,g)}const T=e(d,[["render",u]]);export{k as __pageData,T as default};
