import{_ as t,c as s,o as a,a4 as e}from"./chunks/framework.uQk9_EO2.js";const i="/docs/cocos/assets/backend.CJd9QxgW.jpg",l="/docs/cocos/assets/add-capsule-charactercontroller.BC-icEBm.jpg",r="/docs/cocos/assets/capsule-property.DzOgZepP.jpg",n="/docs/cocos/assets/add-box-charactercontroller.esNccayq.jpg",o="/docs/cocos/assets/box-property.BhPcI2wK.jpg",f=JSON.parse('{"title":"角色控制器","description":"","frontmatter":{},"headers":[],"relativePath":"zh/physics/character-controller/index.md","filePath":"zh/physics/character-controller/index.md","lastUpdated":1712305443000}'),h={name:"zh/physics/character-controller/index.md"},p=e('<h1 id="角色控制器" tabindex="-1">角色控制器 <a class="header-anchor" href="#角色控制器" aria-label="Permalink to &quot;角色控制器&quot;">​</a></h1><blockquote><p>自 v3.8 开始，Cocos Creator 提供角色控制器。</p></blockquote><p>角色控制可以为您的游戏添加简单易用的角色控制功能。</p><h2 id="添加角色控制器" tabindex="-1">添加角色控制器 <a class="header-anchor" href="#添加角色控制器" aria-label="Permalink to &quot;添加角色控制器&quot;">​</a></h2><p>Cocos Creator 提供两种角色控制器类型：盒控制器和胶囊控制器。他们都继承自 <code>CharacterController</code>。</p><p>需要注意的是，角色控制器仅支持 <strong>Bullet</strong> 以及 <strong>PhysX</strong> 物理后端。请在编辑器顶部菜单 <strong>项目</strong> -&gt; <strong>项目设置</strong> 中的 <strong>功能剪裁</strong> 分页中找到 <strong>物理系统</strong>，并将物理后端修改为 <strong>Bullet Based Physics System</strong> 或 <strong>PhysX Based Physics System</strong>（默认的物理后端是 Bullet）。</p><p><img src="'+i+'" alt="backend.jpg"></p><h3 id="通用属性" tabindex="-1">通用属性 <a class="header-anchor" href="#通用属性" aria-label="Permalink to &quot;通用属性&quot;">​</a></h3><p>以下属性为角色控制器的通用属性，您可以在 <strong>盒角色控制器</strong> 和 <strong>胶囊体角色控制器</strong> 的 <strong>属性检查器</strong> 面板找到它们。</p><table><thead><tr><th style="text-align:left;">属性</th><th style="text-align:left;">描述</th></tr></thead><tbody><tr><td style="text-align:left;">Group</td><td style="text-align:left;">物理分组，更多请参考 <strong>项目</strong> -&gt; <strong>项目设置</strong> 的物理分页中 <a href="./../physics-group-mask">碰撞矩阵</a></td></tr><tr><td style="text-align:left;">Min Move Distance</td><td style="text-align:left;">角色控制器的最小移动距离，每次 move 时如果低于这个距离则不会移动</td></tr><tr><td style="text-align:left;">Center</td><td style="text-align:left;">角色控制器的中心</td></tr><tr><td style="text-align:left;">Step Offset</td><td style="text-align:left;">最大自动爬台阶高度</td></tr><tr><td style="text-align:left;">Slope Limit</td><td style="text-align:left;">角色可以行走的最大坡度，单位：角度</td></tr><tr><td style="text-align:left;">Skin Width</td><td style="text-align:left;">控制器使用的皮肤宽度。请参考下方 <strong>皮肤宽度</strong> 获取更多信息。</td></tr></tbody></table><h3 id="胶囊体角色控制器" tabindex="-1">胶囊体角色控制器 <a class="header-anchor" href="#胶囊体角色控制器" aria-label="Permalink to &quot;胶囊体角色控制器&quot;">​</a></h3><p>若要添加胶囊体角色控制器，在 <strong>属性检查器</strong> 面板上点击 <strong>添加组件</strong> 按钮，并选择 <strong>CapsuleCharacterController</strong>：</p><p><img src="'+l+'" alt="add-capsule-charactercontroller.jpg"></p><h4 id="属性" tabindex="-1">属性 <a class="header-anchor" href="#属性" aria-label="Permalink to &quot;属性&quot;">​</a></h4><p><img src="'+r+'" alt="capsule-property.jpg"></p><table><thead><tr><th style="text-align:left;">属性</th><th style="text-align:left;">描述</th></tr></thead><tbody><tr><td style="text-align:left;">Radius</td><td style="text-align:left;">胶囊碰撞体的半径</td></tr><tr><td style="text-align:left;">Height</td><td style="text-align:left;">胶囊体末端两个球心的距离</td></tr></tbody></table><h3 id="盒角色控制器" tabindex="-1">盒角色控制器 <a class="header-anchor" href="#盒角色控制器" aria-label="Permalink to &quot;盒角色控制器&quot;">​</a></h3><p>若要添加盒角色控制器，在 <strong>属性检查器</strong> 面板上点击 <strong>添加组件</strong> 按钮，并选择 <strong>BoxCharacterController</strong>：</p><p><img src="'+n+'" alt="add-box-charactercontroller.jpg"></p><h4 id="属性-1" tabindex="-1">属性 <a class="header-anchor" href="#属性-1" aria-label="Permalink to &quot;属性&quot;">​</a></h4><p><img src="'+o+`" alt="box-property.jpg"></p><table><thead><tr><th style="text-align:left;">属性</th><th style="text-align:left;">描述</th></tr></thead><tbody><tr><td style="text-align:left;">Half Height</td><td style="text-align:left;">盒碰撞体在 Y 轴上的高度的一半</td></tr><tr><td style="text-align:left;">Half Side Extent</td><td style="text-align:left;">盒碰撞体在 X 轴上的高度的一半</td></tr><tr><td style="text-align:left;">Half Forward Extent</td><td style="text-align:left;">盒碰撞体在 Z 轴上的高度的一半</td></tr></tbody></table><h2 id="驱动角色控制器" tabindex="-1">驱动角色控制器 <a class="header-anchor" href="#驱动角色控制器" aria-label="Permalink to &quot;驱动角色控制器&quot;">​</a></h2><p>如果要驱动角色控制器移动，可以使用 <code>move</code> 方法，代码示例如下：</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> movement</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> v3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> characterController </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.node.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getComponent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(CharacterController);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">characterController.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">move</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(movement);</span></span></code></pre></div><p><code>move</code> 方法会考量行进路线中的碰撞体，内部使用了 <code>sweep</code> 的算法去检测，检测碰到物体后，一方面会判断控制器和物体的夹角，如果小于最大爬坡角度（Slope Limit），控制器会接着沿物体表面走；另一方面会考虑碰到控制器和物体的高度差，如果小于最大自动爬台阶高度（Step Offset）也会接着沿物体表面走。如果这两个都不满足，控制器就会停下来。</p><p>如果要重置角色的位置，请使用角色控制器的 <code>setPosition</code> 而不是节点的 <code>setPosition</code>，代码示例如下：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>let characterController = this.node.getComponent(CharacterController);</span></span>
<span class="line"><span>characterController.setPosition(new Vec3(-3,5,6));</span></span></code></pre></div><p>使用角色控制器的 <code>setPosition</code> 移动节点时，会和物理系统同步；而如果只使用节点的 <code>setPosition</code> 或者 <code>setWorldPosition</code>，可能造成节点位置和物理世界内的位置不同步现象。</p><blockquote><p>这里是因为每帧当角色控制器从渲染场景到物理场景的同步时，还需要考量角色控制器的中心偏移。</p></blockquote><p>需要注意的是，角色控制器是不受力影响的，因此开发者需要自行处理角色控制器的受力或者速度。</p><h2 id="判断是否在地面上" tabindex="-1">判断是否在地面上 <a class="header-anchor" href="#判断是否在地面上" aria-label="Permalink to &quot;判断是否在地面上&quot;">​</a></h2><p>通过 <code>isGrounded</code> 方法，可以判定角色控制器是否站在某些碰撞体上，代码示例如下：</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> characterController </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.node.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getComponent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(CharacterController);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> isOnGround</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> characterController.isGrounded;</span></span></code></pre></div><h2 id="监听角色碰撞" tabindex="-1">监听角色碰撞 <a class="header-anchor" href="#监听角色碰撞" aria-label="Permalink to &quot;监听角色碰撞&quot;">​</a></h2><p>当角色控制器和碰撞体发生碰撞时，会派发 <code>onControllerColliderHit</code> 事件，代码参考如下：</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> characterController </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.node.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getComponent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(CharacterController)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">characterController.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">on</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;onControllerColliderHit&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.onColliderHit, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div><p>碰撞回调如下：</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">onColliderHit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (hit: CharacterControllerContact){}</span></span></code></pre></div><p>回调参数说明：</p><ul><li>contact： 和其他碰撞体碰撞时的接触信息， API 参考：<a href="./__APIDOC__/zh/class/physics.CharacterControllerContact">CharacterControllerContact</a></li></ul><p>和触发器发生碰撞时的事件包括以下三种：</p><table><thead><tr><th style="text-align:left;">事件</th><th style="text-align:left;">说明</th></tr></thead><tbody><tr><td style="text-align:left;"><code>onControllerTriggerEnter</code></td><td style="text-align:left;">触发开始时触发该事件</td></tr><tr><td style="text-align:left;"><code>onControllerTriggerStay</code></td><td style="text-align:left;">触发保持时会频发触发该事件</td></tr><tr><td style="text-align:left;"><code>onControllerTriggerExit</code></td><td style="text-align:left;">触发结束时触发该事件</td></tr></tbody></table><h2 id="细节说明" tabindex="-1">细节说明 <a class="header-anchor" href="#细节说明" aria-label="Permalink to &quot;细节说明&quot;">​</a></h2><p>模拟角色时，角色通常不是完全的物理对象，也就意味着角色其实并不展示出完整物理特性。在碰撞发生时，角色控制器无法和普通的动力学刚体（Dynamic Rigidbody）一样模拟器受力情况，如果要实现受力效果，可以在碰撞回调中改变位置、速度信息来模拟物理现象。</p><p>如果要模拟完全受力的物理现象，请使用 <a href="./../physics-rigidbody">动力学刚体</a>。同时需要注意的是持有角色控制器的节点上，如果再添加其他刚体，可能会导致无法预知的错误。通常来说并不建议这么做。</p><p>如果场景中有多个角色控制器，控制器之间并不会产生物理反应。该功能会在后续版本中添加。</p><h3 id="皮肤宽度" tabindex="-1">皮肤宽度 <a class="header-anchor" href="#皮肤宽度" aria-label="Permalink to &quot;皮肤宽度&quot;">​</a></h3><p>皮肤宽度允许控制器和对象之前发生碰撞时，可以产生轻微的穿透从而避免抖动或者卡住。</p><p>通常为一个较小且为正的浮点数。</p><p>如果出现频繁卡住的问题，可以尝试调大 <strong>皮肤宽度</strong> 属性，来避免数字精度的问题。</p><h2 id="示例" tabindex="-1">示例 <a class="header-anchor" href="#示例" aria-label="Permalink to &quot;示例&quot;">​</a></h2><p>角色控制器的示例地址为 <a href="https://github.com/cocos/cocos-example-projects" target="_blank" rel="noreferrer">GIT</a>，下载完成后打开 <strong>case-character-controller.scene</strong> 场景运行即可。</p><h2 id="api" tabindex="-1">API <a class="header-anchor" href="#api" aria-label="Permalink to &quot;API&quot;">​</a></h2><p>角色控制器的 API 请参考 <a href="./__APIDOC__/zh/class/physics.CharacterController">角色控制器</a>、<a href="./__APIDOC__/zh/class/physics.BoxCharacterController">盒角色控制器</a> 以及 <a href="./__APIDOC__/zh/class/physics.CapsuleCharacterController">胶囊体角色控制器</a></p><h2 id="支持情况" tabindex="-1">支持情况 <a class="header-anchor" href="#支持情况" aria-label="Permalink to &quot;支持情况&quot;">​</a></h2><p>该功能在抖音的小程序 wasm 上不支持。如要启用，请使用 Cocos Creator 自带的 wasm。</p>`,57),d=[p];function c(g,k,y,C,E,u){return a(),s("div",null,d)}const x=t(h,[["render",c]]);export{f as __pageData,x as default};
