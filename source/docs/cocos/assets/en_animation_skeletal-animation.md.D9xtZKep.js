import{_ as e,c as t,o as n,a4 as a}from"./chunks/framework.uQk9_EO2.js";const i="/docs/cocos/assets/sockets-attach0.CHEzEY7u.png",s="/docs/cocos/assets/sockets-attach1.BuuZ8IBJ.gif",o="/docs/cocos/assets/batched-skinning-model-component.Clx51DGN.png",y=JSON.parse('{"title":"Skeletal Animation","description":"","frontmatter":{},"headers":[],"relativePath":"en/animation/skeletal-animation.md","filePath":"en/animation/skeletal-animation.md","lastUpdated":1712305443000}'),l={name:"en/animation/skeletal-animation.md"},r=a('<h1 id="skeletal-animation" tabindex="-1">Skeletal Animation <a class="header-anchor" href="#skeletal-animation" aria-label="Permalink to &quot;Skeletal Animation&quot;">​</a></h1><p>Skeletal animation is a common but special type of animation. We provide two systems, <strong>pre-baked skeletal animation</strong> and <strong>realtime computed skeletal animation</strong>, optimized for different directions.</p><p>The only switch between these two systems is the <code>useBakedAnimation</code> property in the <strong>SkeletalAnimation</strong> component, which can also be switched seamlessly at runtime.</p><ul><li>When <code>useBakedAnimation</code> is enabled, the pre-baked skeletal animation system is used.</li><li>When <code>useBakedAnimation</code> is disabled, the real-time computed skeletal animation system will be used.</li></ul><p>For the component interface of skeletal animation, please refer to the <a href="./__APIDOC__/en/class/SkeletalAnimation">SkeletalAnimation API</a>.</p><h2 id="pre-baked-skeletal-animation-system" tabindex="-1">Pre-baked Skeletal Animation System <a class="header-anchor" href="#pre-baked-skeletal-animation-system" aria-label="Permalink to &quot;Pre-baked Skeletal Animation System&quot;">​</a></h2><p>The overriding purpose of this system is performance, so some of the sacrifice of expressiveness is considered acceptable. We have targeted a number of underlying optimizations, and the current runtime flow is roughly as follows:</p><ul><li>All animation data is pre-sampled and baked in advance to a globally reused skeletal animation texture ensemble at a specified frame rate.</li><li>Depending on whether the runtime platform supports floating point textures or not, an alternate scheme in <strong>RGBA32F</strong> or <strong>RGBA8</strong> format is used (this step of the process is of no concern to the user and will have no impact on the final performance, but is only a final underwriting strategy for low-end platforms).</li><li>Each skeletal animation component (<strong>SkeletalAnimation</strong>) is responsible for maintaining the current playback progress, stored as a UBO (a Vec4).</li><li>Each skinning model component (<strong>SkinnedMeshRenderer</strong>) holds the pre-baked skinning model class (BakedSkinningModel), calculates culling based on the same pre-baked wrap-around box information, updates the UBO, and finishes skinning by fetching the current data from within the texture ensemble on the GPU.</li></ul><h2 id="real-time-computed-skeletal-animation-system" tabindex="-1">Real-time Computed Skeletal Animation System <a class="header-anchor" href="#real-time-computed-skeletal-animation-system" aria-label="Permalink to &quot;Real-time Computed Skeletal Animation System&quot;">​</a></h2><p>The overwhelming purpose of this system is expressiveness, ensuring that all details are displayed correctly, and complete programmatic control.</p><p>The current runtime flow is roughly as follows:</p><ul><li>All animation data is dynamically interpolated and calculated based on the current global time.</li><li>Animation data is exported to the skeletal node tree of the scene.</li><li>The user and any other system can have an effect on the skinning effect by manipulating this skeleton node tree.</li><li>Each skinning model component (SkinnedMeshRenderer) holds the common skinning model class (SkinningModel), extracts the skeleton node tree information each frame to calculate culling, uploads the complete skeleton transformation information of the current frame to UBO, and finishes skinning inside the GPU. For more information about skinning, please refer to the <strong>Skinning Algorithm</strong> section below.</li></ul><p>This provides the most basic support for all the following functions:</p><ul><li>blendshape support</li><li>Blending and masking of an arbitrary number of animation clips</li><li>IK, secondary physical effects</li><li>purely procedural control of joint positions</li></ul><h2 id="selection-of-two-systems-and-best-practices" tabindex="-1">Selection of two systems and best practices <a class="header-anchor" href="#selection-of-two-systems-and-best-practices" aria-label="Permalink to &quot;Selection of two systems and best practices&quot;">​</a></h2><p>Currently all model assets are imported with <strong>pre-baking system</strong> in Prefab by default for best performance. It is recommended to use the <strong>real-time computing system</strong> only when it becomes apparent that the performance of the pre-baking system is not up to par.</p><blockquote><p><strong>Note</strong>: although the two systems can be switched seamlessly at runtime, try not to do that at high frequencies, as each switch involves the reconstruction of the underlying rendering data.</p></blockquote><h2 id="skinning-algorithms" tabindex="-1">Skinning Algorithms <a class="header-anchor" href="#skinning-algorithms" aria-label="Permalink to &quot;Skinning Algorithms&quot;">​</a></h2><p>Creator provides two common standard skinning algorithms built-in, which have similar performance and only have an impact on the final performance.</p><ol><li><strong>LBS (Linear Blending Skinning)</strong>: skeletal information is stored as a <strong>3 x 4</strong> matrix, and skinning is achieved by direct linear interpolation of the matrix. Currently there are typical known issues such as volume loss.</li><li><strong>DQS (Dual Quaternion Skinning)</strong>: skeletal information is interpolated as <strong>Dual Quaternion</strong>, which is more accurate and natural for skeletal animations that do not contain scaling transformations, but has approximate simplification for all scaling animations for performance reasons.</li></ol><p>The engine uses LBS by default, and the masking algorithm can be switched by modifying the <code>updateJointData</code> function reference in the engine <code>skeletal-animation-utils.ts</code> and the header file reference in <code>cc-skinning.chunk</code>.</p><p>It is recommended that projects with high quality skinning animations try to enable DQS, but since there is no <code>fma</code> instruction until GLSL 400, operations such as <code>cross</code> cannot bypass the floating point offset problem on some GPUs and have large errors, which may introduce some visible defects.</p><h2 id="socket-system" tabindex="-1">Socket System <a class="header-anchor" href="#socket-system" aria-label="Permalink to &quot;Socket System&quot;">​</a></h2><p>If you need to attach some external nodes to a given skeletal joint, making them transform with skeletal joint together, you may need to use the <strong>Socket System</strong> of the skeletal animation component. Here is a simple example.</p><h3 id="implementing-via-the-editor" tabindex="-1">Implementing via the editor <a class="header-anchor" href="#implementing-via-the-editor" aria-label="Permalink to &quot;Implementing via the editor&quot;">​</a></h3><ol><li>Create a new child node under the skeletal animation component to be docked (the immediate parent node should be the node where the animation component is located).</li><li>Add an array element to the <strong>Sockets</strong> property of the skeletal animation component, select the <strong>Path</strong> of the skeleton to be attached from the drop-down list (note that the defaultClip of the skeletal animation component must have a value, the options in the drop-down list depend on this property), and specify the child node just created as the <strong>Target</strong>.</li><li>This child node becomes the target socket, any external node can be put under this child node and will follow the transformation of the specified skeleton.</li></ol><p><img src="'+i+`" alt="attach0"></p><h3 id="implementing-via-code" tabindex="-1">Implementing via code <a class="header-anchor" href="#implementing-via-code" aria-label="Permalink to &quot;Implementing via code&quot;">​</a></h3><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> target </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Node</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.cubeNode.parent </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> target; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// The cubeNode contains a cube model</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> skeletalAnimation </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.node.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getComponent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(SkeletalAnimation);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">target.parent </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> skeletalAnimation.node; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Setting target&#39;s parent node which contain a SkeletalAnimation component.</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> path </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;root/_rootJoint/b_Root_00/b_Hip_01/b_Tail01_012/b_Tail02_013/b_Tail03_014&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> socket </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> SkeletalAnimation.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Socket</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(path, target); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Create Socket object with path and target</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">skeletalAnimation.sockets.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">push</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(socket);</span></span></code></pre></div><p>Click the Preview button, you will see the cube handing from the fox&#39;s tail and shaking along with the fox&#39;s tail.</p><p><img src="`+s+'" alt="attach1"></p><p>The socket model in the <strong>FBX</strong> or <strong>glTF</strong> asset will automatically interface to the socket system without any manual operation.</p><h2 id="about-dynamic-instancing" tabindex="-1">About Dynamic Instancing <a class="header-anchor" href="#about-dynamic-instancing" aria-label="Permalink to &quot;About Dynamic Instancing&quot;">​</a></h2><p>Based on the framework design of the <strong>pre-baking system</strong>, instancing of the skinned model is also within reach, but there is some more underlying information that needs to be collected to ensure correctness.</p><p>The fundamental problem here is that each model within the same drawcall must use the same skeleton texture, if not, the display will be completely misaligned. So how the animation data is assigned to each skeleton texture becomes a user-defined piece of information that can be configured in the <a href="./joint-texture-layout">Joint Texture Layout</a> panel in the editor menu bar <strong>Panel -&gt; Animation</strong>.</p><blockquote><p><strong>Notes</strong>:</p><ol><li>Instancing is only supported under the <strong>pre-baking system</strong>. we have not strictly forbidden to enable instancing under the <strong>real-time computation framework</strong> (only in-editor warnings), but the animation effect will definitely be problematic, depending on the actual material assignment of the model. In the best case, the animation will be identical from instance to instance, in the worst case it will cause the model to be completely misaligned.</li><li>For models with instancing enabled in the material, the planar shading system will automatically draw with instancing as well. In particular, shading batches of skinned models require a higher level of joint texture layout, since the pipeline state of shading is uniform, and <strong>all animations of skinned models with shadow enabled</strong> need to be on the same texture (as opposed to drawing the model itself, which only requires consistent joint textures between instances within the same Drawcall).</li></ol></blockquote><h2 id="skinned-mesh-batch-renderer" tabindex="-1">Skinned Mesh Batch Renderer <a class="header-anchor" href="#skinned-mesh-batch-renderer" aria-label="Permalink to &quot;Skinned Mesh Batch Renderer&quot;">​</a></h2><p>Currently, the joint textures uploaded to GPU on the bottom layer has been automatically batched and reused globally, and the upper layer data can now be combined by using the <strong>SkinnedMeshBatchRenderer</strong> component to merge all sub-skinned models controlled by the same skeletal animation component:</p><p><img src="'+o+'" alt="batched-skinning-model"></p><p>The batched version of effect is a bit more complicated to write, but basically it can be based on the normal effect used for sub-materials, with some relatively straightforward preprocessing and interface changes. See <code>builtin-unlit</code> in the editor&#39;s built-in asset (<code>util/batched-unlit</code>).</p><blockquote><p><strong>Note</strong>: only the pre-baked system can guarantee correctness when using the batch skinned model component, although it can be used in the real-time computing framework, there will be rendering problems when the number of merged skeletons exceeds 30 (the maximum number of Uniform arrays).</p></blockquote><h3 id="skinnedmeshbatchrenderer-component-properties" tabindex="-1">SkinnedMeshBatchRenderer component properties <a class="header-anchor" href="#skinnedmeshbatchrenderer-component-properties" aria-label="Permalink to &quot;SkinnedMeshBatchRenderer component properties&quot;">​</a></h3><table><thead><tr><th style="text-align:left;">Property</th><th style="text-align:left;">Description</th></tr></thead><tbody><tr><td style="text-align:left;">Operation</td><td style="text-align:left;">Any changes will not take effect until <strong>Cook</strong> button is clicked to recalculate and apply.</td></tr><tr><td style="text-align:left;">Materials</td><td style="text-align:left;">Custom effect is needed for this final material - the shader code should handle all the intricacies of the batching process.</td></tr><tr><td style="text-align:left;">LightmapSettings</td><td style="text-align:left;">Used for lightmapping, please refer to <a href="./.../../../concepts/scene/light/lightmap">Lightmapping</a> for details.</td></tr><tr><td style="text-align:left;">ShadowCastingMode</td><td style="text-align:left;">Specifies whether the current model will cast shadows, which needs to <a href="./.../../../concepts/scene/light/shadow#enable-shadow-effect">enable shadow effect</a> in the scene first.</td></tr><tr><td style="text-align:left;">ReceiveShadow</td><td style="text-align:left;">Specifies whether the current model will receive and display shadow effects generated by other objects, which needs to <a href="./.../../../concepts/scene/light/shadow#enable-shadow-effect">enable shadow effect</a> in the scene first. This property takes effect only when the type of shadows is ShadowMap.</td></tr><tr><td style="text-align:left;">SkinningRoot</td><td style="text-align:left;">The root node of the skeletal skin, usually the node where the SkeletalAnimationComponent is located.</td></tr><tr><td style="text-align:left;">AtlasSize</td><td style="text-align:left;">The side length of the generated final atlas.</td></tr><tr><td style="text-align:left;">BatchableTextureNames</td><td style="text-align:left;">The properties of the textures in the material that are actually involved in the atlas, and those are not involved use the texture of the first unit uniformly.</td></tr><tr><td style="text-align:left;">Units</td><td style="text-align:left;">The sub-model infos before batching, which is the main source of data.</td></tr><tr><td style="text-align:left;">Mesh</td><td style="text-align:left;">The model data of the current sub-model, usually from glTF or FBX.</td></tr><tr><td style="text-align:left;">Skeleton</td><td style="text-align:left;">The skeletal data of the current sub-model, usually from glTF or FBX.</td></tr><tr><td style="text-align:left;">Material</td><td style="text-align:left;">The &quot;sub-material&quot; used by the current sub-model is a non-batched version of the normal effect, and the effect used by different sub-models should be consistent.</td></tr><tr><td style="text-align:left;">Offset</td><td style="text-align:left;">The offset of the current sub-model&#39;s textures inside the atlas, with the top-left corner of the atlas as the origin, in the range [0, 1], e.g.: the data in the figure represents that the sub-texture overlaps with the top-left corner of the atlas.</td></tr><tr><td style="text-align:left;">Size</td><td style="text-align:left;">The size occupied by the current sub-model&#39;s textures inside the atlas, in the range [0, 1], e.g.: the data in the figure represents that the sub-texture occupies 1/2 of the entire atlas.</td></tr><tr><td style="text-align:left;">CopyFrom</td><td style="text-align:left;">The target properties (except offset and size) can be copied automatically by dragging in the SkinningModelComponent for easy operation.</td></tr></tbody></table>',43),h=[r];function d(c,p,m,g,k,u){return n(),t("div",null,h)}const b=e(l,[["render",d]]);export{y as __pageData,b as default};
