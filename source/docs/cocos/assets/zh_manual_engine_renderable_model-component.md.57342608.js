import{_ as r,v as n,b as l,F as s,L as t,E as o,O as d,R as e,M as i}from"./chunks/framework.5ffcbaff.js";const h="/docs/cocos/assets/meshrenderer-properties.c3e00bd9.png",c="/docs/cocos/assets/create-model.315cc78e.png",g="/docs/cocos/assets/view-model.8d82b27b.gif",R=JSON.parse('{"title":"MeshRenderer 组件参考","description":"","frontmatter":{},"headers":[],"relativePath":"zh/manual/engine/renderable/model-component.md","filePath":"zh/manual/engine/renderable/model-component.md"}'),f={name:"zh/manual/engine/renderable/model-component.md"},p=e('<h1 id="meshrenderer-组件参考" tabindex="-1">MeshRenderer 组件参考 <a class="header-anchor" href="#meshrenderer-组件参考" aria-label="Permalink to &quot;MeshRenderer 组件参考&quot;">​</a></h1><p>MeshRenderer（网格渲染器）组件用于显示一个静态的 3D 模型。通过 <strong>Mesh</strong> 属性设置模型网格，通过 <strong>Materials</strong> 属性控制模型的显示外观。</p><p>在 <strong>属性检查器</strong> 中点击 <strong>添加组件 -&gt; Mesh -&gt; MeshRenderer</strong> 即可添加 MeshRenderer 组件。</p><p><img src="'+h+'" alt="Mesh Renderer properties"></p><h2 id="meshrenderer-属性" tabindex="-1">MeshRenderer 属性 <a class="header-anchor" href="#meshrenderer-属性" aria-label="Permalink to &quot;MeshRenderer 属性&quot;">​</a></h2><table><thead><tr><th style="text-align:left;">属性</th><th style="text-align:left;">功能</th></tr></thead><tbody><tr><td style="text-align:left;"><strong>Materials</strong></td><td style="text-align:left;">网格资源允许使用多个材质资源，所有材质资源都存在 <code>materials</code> 数组中。<br>如果网格资源中有多个子网格，那么 Mesh Renderer 会从 <code>materials</code> 数组中获取对应的材质来渲染此子网格。</td></tr><tr><td style="text-align:left;"><strong>Dynamic Shadow Settings</strong></td><td style="text-align:left;">动态阴影配置，详情请参考下方 <strong>动态阴影配置</strong> 文档</td></tr><tr><td style="text-align:left;"><strong>Bake Settings</strong></td><td style="text-align:left;">烘焙配置，详情请参考下方 <strong>烘焙配置</strong> 文档</td></tr><tr><td style="text-align:left;"><strong>Mesh</strong></td><td style="text-align:left;">指定渲染所用的网格资源，详情请参考下文 <strong>网格资源</strong> 部分的内容</td></tr></tbody></table><h3 id="动态阴影配置" tabindex="-1">动态阴影配置 <a class="header-anchor" href="#动态阴影配置" aria-label="Permalink to &quot;动态阴影配置&quot;">​</a></h3><table><thead><tr><th style="text-align:left;">属性</th><th style="text-align:left;">说明</th></tr></thead><tbody><tr><td style="text-align:left;"><strong>Shadow Bias</strong></td><td style="text-align:left;">阴影偏移</td></tr><tr><td style="text-align:left;"><strong>Shadow Normal Bias</strong></td><td style="text-align:left;">阴影法线偏移</td></tr><tr><td style="text-align:left;"><strong>Shadow Casting Mode</strong></td><td style="text-align:left;">指定当前模型是否会投射阴影，需要先在场景中 <a href="./../../concepts/scene/light/shadow.html#开启阴影">开启阴影</a>。</td></tr><tr><td style="text-align:left;"><strong>Receive Shadow</strong></td><td style="text-align:left;">指定当前模型是否会接收并显示其它物体产生的阴影效果，需要先在场景中 <a href="./../../concepts/scene/light/shadow.html#开启阴影">开启阴影</a>。该属性仅在阴影类型为 <strong>ShadowMap</strong> 时生效。</td></tr></tbody></table><h3 id="烘焙配置" tabindex="-1">烘焙配置 <a class="header-anchor" href="#烘焙配置" aria-label="Permalink to &quot;烘焙配置&quot;">​</a></h3><p>烘焙设置指的是网格如何使用或写入离线光照信息。</p><p>该配置包含：<a href="./../../concepts/scene/light/lightmap.html">光照贴图</a>、<a href="./probe/light-probe.html">光照探针</a> 和 <a href="./../../concepts/scene/light/probe/reflection-probe.html">反射探针</a>。</p><h4 id="光照贴图" tabindex="-1">光照贴图 <a class="header-anchor" href="#光照贴图" aria-label="Permalink to &quot;光照贴图&quot;">​</a></h4><table><thead><tr><th style="text-align:left;">属性</th><th style="text-align:left;">说明</th></tr></thead><tbody><tr><td style="text-align:left;"><strong>Bakeable</strong></td><td style="text-align:left;">是否会被烘焙到光照贴图内</td></tr><tr><td style="text-align:left;"><strong>Cast Shadow</strong></td><td style="text-align:left;">是否投射阴影</td></tr><tr><td style="text-align:left;"><strong>Receive Shadow</strong></td><td style="text-align:left;">是否接收阴影</td></tr><tr><td style="text-align:left;"><strong>Lightmap Size</strong></td><td style="text-align:left;">光照贴图的大小</td></tr></tbody></table><h4 id="光照探针" tabindex="-1">光照探针 <a class="header-anchor" href="#光照探针" aria-label="Permalink to &quot;光照探针&quot;">​</a></h4><table><thead><tr><th style="text-align:left;">属性</th><th style="text-align:left;">说明</th></tr></thead><tbody><tr><td style="text-align:left;"><strong>Use Light Probe</strong></td><td style="text-align:left;">配置是否使用光照探针</td></tr><tr><td style="text-align:left;"><strong>Bake To Light Probe</strong></td><td style="text-align:left;">配置是否烘焙光照探针</td></tr></tbody></table><h4 id="反射探针" tabindex="-1">反射探针 <a class="header-anchor" href="#反射探针" aria-label="Permalink to &quot;反射探针&quot;">​</a></h4><table><thead><tr><th style="text-align:left;">属性</th><th style="text-align:left;">说明</th></tr></thead><tbody><tr><td style="text-align:left;"><strong>Reflection Probe</strong></td><td style="text-align:left;"><a href="./../../concepts/scene/light/probe/reflection-probe.html">反射探针</a> 的类型 <br> 支持 <strong>PLANNAR_REFLECTION</strong> 和 <strong>CUBE_REFLECTION</strong> <br> <strong>PLANNAR_REFLECTION</strong>：配置为动态反射探针 <br> <strong>CUBE_REFLECTION</strong>：配置为使用烘焙后的反射探针</td></tr><tr><td style="text-align:left;"><strong>Bake To Reflection Probe</strong></td><td style="text-align:left;">配置是否烘焙至反射探针生成的贴图内</td></tr></tbody></table><p>网格渲染器组件相关接口请参考 <a href="./__APIDOC__/zh/class/MeshRenderer.html">MeshRenderer API</a>。</p><p>蒙皮网格渲染器组件相关接口请参考 <a href="./__APIDOC__/zh/class/SkinnedMeshRenderer.html">SkinnedMeshRenderer API</a></p><h3 id="网格资源" tabindex="-1">网格资源 <a class="header-anchor" href="#网格资源" aria-label="Permalink to &quot;网格资源&quot;">​</a></h3><p>Mesh 资源是渲染网格的必要资源，目前网格主要是在 <a href="./../../asset/model/mesh.html#模型导入">导入模型资源</a> 到 Creator 中时，由 Creator 自动生成的。</p><p>Mesh 资源中包含了一组顶点和多组索引。索引指向顶点数组中的顶点，每三组索引组成一个三角形。网格则是由多个三角形组成的，是 3D 世界中最基本的图元。多个三角形拼接成一个复杂的多边形，多个多边形则拼接成一个 3D 模型。</p><p>Creator 提供了几个简单的静态 3D 模型，其中包含了立方体、圆柱体等基础模型，开发者可根据自己的需要在 <strong>层级管理器</strong> 中创建几个，以初步了解。</p><p><img src="'+c+'" alt="create model"></p><h2 id="模型分组渲染" tabindex="-1">模型分组渲染 <a class="header-anchor" href="#模型分组渲染" aria-label="Permalink to &quot;模型分组渲染&quot;">​</a></h2><p>分组渲染功能是通过相机组件的 <a href="./../../editor/components/camera-component.html#设置-visibility-属性">Visibility 属性</a> 配合节点的 <a href="./../../concepts/scene/node-component.html#设置节点的-layer-属性">Layer 属性</a> 共同决定。用户可通过代码设置 <code>Visibility</code> 的值来完成分组渲染。所有节点默认都属于 <strong>DEFAULT</strong> 层，在所有相机都可见。</p><h2 id="静态合批" tabindex="-1">静态合批 <a class="header-anchor" href="#静态合批" aria-label="Permalink to &quot;静态合批&quot;">​</a></h2><p>目前静态合批方案为运行时静态合批，通过调用 <code>BatchingUtility.batchStaticModel</code> 可进行静态合批。<br> 该函数接收一个节点，然后将该节点下的所有 <code>MeshRenderer</code> 里的 <code>Mesh</code> 合并成一个，并将其挂到另一个节点下。<br> 在合批后，将无法改变原有的 <code>MeshRenderer</code> 的 <code>transform</code>，但可以改变合批后的根节点的 <code>transform</code>。</p><p>只有满足以下条件的节点才能进行静态合批：</p><ul><li>子节点中只能包含 <code>MeshRenderer</code>；</li><li>子节点下的 <code>MeshRenderer</code> 的 <code>Mesh</code> 的顶点数据结构必须一致；</li><li>子节点下的 <code>MeshRenderer</code> 的材质必须相同。</li></ul><h2 id="动态合批" tabindex="-1">动态合批 <a class="header-anchor" href="#动态合批" aria-label="Permalink to &quot;动态合批&quot;">​</a></h2><p>引擎目前提供 instancing 动态合批功能。<br> 要开启合批，只需在模型所使用的材质中对应勾选 <code>USE_INSTANCING</code> 开关即可。</p><blockquote><p><strong>注意</strong>：目前的合批流程会引入一些限制：</p><ol><li>同一批次的透明模型间的绘制顺序无法保证，可能导致混合效果不准确；</li><li>合批后没有传递逆转置世界矩阵信息，带有非均一缩放的模型的法线会不准确；</li><li>只支持普通 3D 模型和预烘焙骨骼动画控制下的蒙皮模型（实时计算骨骼动画、2D 物体、UI、粒子等均不支持动态合批）。</li></ol></blockquote><h3 id="instancing-合批" tabindex="-1">Instancing 合批 <a class="header-anchor" href="#instancing-合批" aria-label="Permalink to &quot;Instancing 合批&quot;">​</a></h3><p>通过 Instancing 的合批适用于绘制大量顶点数据完全相同的动态模型，启用后绘制时会根据材质和顶点数据分组，每组内组织 instanced attributes 信息，然后一次性完成绘制。</p><p>关于蒙皮模型的支持及相关设定，参考 <a href="./../../animation/skeletal-animation.html#关于动态-Instancing">骨骼动画组件</a>。</p><p>另外 instancing 还支持自定义额外的 instanced attributes，可以传递更多不同 instance 之间的差异性数据（比如不同人物间给一个漫反射颜色的外观差异，或大片草地中的风力影响）。<br> 这需要自定义 effect 的支持，更详细的说明可以参考 <a href="./../../shader/effect-syntax.html#自定义几何体实例化属性">语法指南</a></p><h3 id="合并-vb-合批" tabindex="-1">合并 VB 合批 <a class="header-anchor" href="#合并-vb-合批" aria-label="Permalink to &quot;合并 VB 合批&quot;">​</a></h3><p>考虑到合并 VB 合批在每帧合并顶点等操作会引入一部分 CPU 开销，相当于是用CPU开销来替换 drawcall 的开销（大多数情况下前者反而要大于后者，在 JS 中尤其昂贵），未经严格测试的滥用反而会引起性能降低，<strong>此功能在3.6.2已移除，请优先使用 Instancing 或静态合批来替代</strong>。</p>',39),b=e('<h2 id="合批的最佳实践" tabindex="-1">合批的最佳实践 <a class="header-anchor" href="#合批的最佳实践" aria-label="Permalink to &quot;合批的最佳实践&quot;">​</a></h2><p>通常来说合批系统的使用优先级为：**静态合批 &gt; instancing 合批 **。<br> 首先要确保材质统一，在这个前提下，如果确定某些模型在游戏周期内完全静止不会变化，就可以使用静态合批。<br> 如果存在大量相同的模型重复绘制，相互间只有相对可控的小差异，就可以使用 instancing 合批。<br></p><h2 id="预览网格" tabindex="-1">预览网格 <a class="header-anchor" href="#预览网格" aria-label="Permalink to &quot;预览网格&quot;">​</a></h2><p>鼠标悬停在 <strong>Mesh</strong> 属性中下拉的网格上时，可以在场景视图中对模型进行预览。</p><p><img src="'+g+'" alt="view model"></p><p>[^1]: 注意目前使用 uniform 上传合批后的世界变换矩阵，考虑到 WebGL 标准的 uniform 数量限制，目前一批最多绘制 10 个模型，所以对大量同材质的模型，开启合批后 drawcall 数量预期最多会减少 10 倍。 [^2]: 关于合批与性能的话题业界一直有不少探讨，比如可以参考 <a href="https://www.nvidia.com/docs/IO/8228/BatchBatchBatch.pdf" target="_blank" rel="noreferrer">这里</a> 的 slide。</p>',6);function m(x,y,u,_,M,q){const a=i("font");return n(),l("div",null,[p,s("p",null,[t("另外需要提醒 "),o(a,{color:"#ff0000"},{default:d(()=>[t("drawcall 数量并非唯一的性能指标[^2]")]),_:1}),t("，最佳性能往往是 CPU 与 GPU 负载均衡的结果，所以在尝试使用合批功能时，请一定多做测试，明确性能瓶颈，做有针对性的优化。")]),b])}const k=r(f,[["render",m]]);export{R as __pageData,k as default};
