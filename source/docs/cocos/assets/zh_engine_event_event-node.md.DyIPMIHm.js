import{_ as t,c as s,o as a,a4 as i}from"./chunks/framework.uQk9_EO2.js";const e="/docs/cocos/assets/bubble-event.Dk5M4WKm.png",n="/docs/cocos/assets/propagation.CI-k_ZzH.png",l="/docs/cocos/assets/multi-canvas.BHp6CTY4.png",h="/docs/cocos/assets/events-block.DVJmnbN_.png",p="/docs/cocos/assets/example.qynUXJU9.png",u=JSON.parse('{"title":"节点事件系统","description":"","frontmatter":{},"headers":[],"relativePath":"zh/engine/event/event-node.md","filePath":"zh/engine/event/event-node.md","lastUpdated":1712305443000}'),d={name:"zh/engine/event/event-node.md"},r=i(`<h1 id="节点事件系统" tabindex="-1">节点事件系统 <a class="header-anchor" href="#节点事件系统" aria-label="Permalink to &quot;节点事件系统&quot;">​</a></h1><p><code>input</code> 对象支持了全局的 <a href="./event-input">输入事件系统</a>，全局输入事件包括鼠标、触摸、键盘和重力传感四种。而 <code>Node</code> 也实现了 <code>EventTarget</code> 的事件监听接口。在此基础上，我们提供了一些基础的节点相关的系统事件。</p><p>本篇文档着重介绍了与 UI 节点树相关联的鼠标和触摸事件，这些事件是被直接触发在 UI 相关节点上的，所以被称为节点事件，使用方式如下：</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">node.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">on</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Node.EventType.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">MOUSE_DOWN</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">event</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Mouse down&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div><blockquote><p><strong>注意</strong>：我们不推荐直接使用事件的名称字符串注册事件监听了。例如上述代码示例，请不要使用 <code>node.on(&#39;mouse-down&#39;, callback, target)</code> 来注册事件监听。</p></blockquote><p>2D UI 节点上的触摸事件监听依赖于 <code>UITransform</code> 组件。如果需要实现对 3D 物体的触摸检测，请参考文档 <a href="./event-input#对 3D 物体的触摸检测">3D 物体的触摸检测</a>。</p><h2 id="鼠标事件类型和事件对象" tabindex="-1">鼠标事件类型和事件对象 <a class="header-anchor" href="#鼠标事件类型和事件对象" aria-label="Permalink to &quot;鼠标事件类型和事件对象&quot;">​</a></h2><p>鼠标事件在 PC 端才会触发，系统提供的事件类型如下：</p><table><thead><tr><th style="text-align:left;">枚举对象定义</th><th style="text-align:left;">事件触发的时机</th></tr></thead><tbody><tr><td style="text-align:left;"><strong>Node.EventType.MOUSE_DOWN</strong></td><td style="text-align:left;">当鼠标在目标节点区域按下时触发一次。</td></tr><tr><td style="text-align:left;"><strong>Node.EventType.MOUSE_ENTER</strong></td><td style="text-align:left;">当鼠标移入目标节点区域时触发，不论是否按下。</td></tr><tr><td style="text-align:left;"><strong>Node.EventType.MOUSE_MOVE</strong></td><td style="text-align:left;">当鼠标在目标节点区域中移动时触发，不论是否按下。</td></tr><tr><td style="text-align:left;"><strong>Node.EventType.MOUSE_LEAVE</strong></td><td style="text-align:left;">当鼠标移出目标节点区域时触发，不论是否按下。</td></tr><tr><td style="text-align:left;"><strong>Node.EventType.MOUSE_UP</strong></td><td style="text-align:left;">当鼠标从按下状态松开时触发一次。</td></tr><tr><td style="text-align:left;"><strong>Node.EventType.MOUSE_WHEEL</strong></td><td style="text-align:left;">当鼠标滚轮滚动时触发。</td></tr></tbody></table><p>鼠标事件（<code>Event.EventMouse</code>）的重要 API 请参考 <a href="./event-api#鼠标事件-API">鼠标事件 API</a>（Event 标准事件 API 除外）。</p><h2 id="触摸事件类型和事件对象" tabindex="-1">触摸事件类型和事件对象 <a class="header-anchor" href="#触摸事件类型和事件对象" aria-label="Permalink to &quot;触摸事件类型和事件对象&quot;">​</a></h2><p>触摸事件在移动端和 PC 端都会触发，开发者若希望更好地在 PC 端进行调试，只需要监听触摸事件即可同时响应移动端的触摸事件和 PC 端的鼠标事件。系统提供的触摸事件类型如下：</p><table><thead><tr><th style="text-align:left;">枚举对象定义</th><th style="text-align:left;">事件触发的时机</th></tr></thead><tbody><tr><td style="text-align:left;"><strong>Node.EventType.TOUCH_START</strong></td><td style="text-align:left;">当手指触点落在目标节点区域内时。</td></tr><tr><td style="text-align:left;"><strong>Node.EventType.TOUCH_MOVE</strong></td><td style="text-align:left;">当手指在屏幕上移动时。</td></tr><tr><td style="text-align:left;"><strong>Node.EventType.TOUCH_END</strong></td><td style="text-align:left;">当手指在目标节点区域内离开屏幕时。</td></tr><tr><td style="text-align:left;"><strong>Node.EventType.TOUCH_CANCEL</strong></td><td style="text-align:left;">当手指在目标节点区域外离开屏幕时。</td></tr></tbody></table><p>触摸事件（<code>Event.EventTouch</code>）的重要 API 请参考 <a href="./event-api#触摸事件-API">触摸事件 API</a>（Event 标准事件 API 除外）。</p><blockquote><p><strong>注意</strong>：触摸事件支持多点触摸，每个触点都会发送一次事件给事件监听器。</p></blockquote><h2 id="节点事件派发" tabindex="-1">节点事件派发 <a class="header-anchor" href="#节点事件派发" aria-label="Permalink to &quot;节点事件派发&quot;">​</a></h2><p>Cocos Creator 在 <code>Node</code> 上支持了 <code>dispatchEvent</code> 接口，通过该接口派发的事件，会进入事件派发阶段。Creator 的事件派发系统是按照 <a href="https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Building_blocks/Events#%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1%E5%8F%8A%E6%8D%95%E8%8E%B7" target="_blank" rel="noreferrer">Web 的事件冒泡及捕获标准</a> 实现的，事件在派发之后，会经历下面三个阶段：</p><ul><li><strong>捕获</strong>：事件从场景根节点，逐级向子节点传递，直到到达目标节点或者在某个节点的响应函数中中断事件传递</li><li><strong>目标</strong>：事件在目标节点上触发</li><li><strong>冒泡</strong>：事件由目标节点，逐级向父节点冒泡传递，直到到达根节点或者在某个节点的响应函数中中断事件传递</li></ul><p>当调用 <code>node.dispatchEvent()</code> 时，意味着 <code>node</code> 就是上文提到的目标节点。在事件的传递过程中，我们可以通过调用 <code>event.propagationStopped = true</code> 来中断事件传递。</p><p>在 v3.0 中，我们移除了 <code>Event.EventCustom</code> 类，如果要派发自定义事件，需要先实现一个自定义的事件类，该类继承自 <code>Event</code> 类，例如：</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Event 由 cc 模块导入</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { Event } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;cc&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MyEvent</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> extends</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Event</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    constructor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">name</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> string</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">bubbles</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">?:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> boolean</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">detail</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">?:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> any</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        super</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(name, bubbles);</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.detail </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> detail;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> detail</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> any</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 自定义的属性</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p><img src="`+e+`" alt="bubble-event"></p><p>以上图为例，这张图展示了事件在 <strong>目标</strong> 和 <strong>冒泡</strong> 阶段的传递顺序。当我们从节点 c 派发事件 <code>“foobar”</code>，倘若节点 a，b 均做了 <code>“foobar”</code> 事件的监听，则事件会经由 c 依次传递给 b、a 节点。代码实现示例如下：</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 节点 c 的组件脚本中</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.node.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">dispatchEvent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">( </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MyEvent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;foobar&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;detail info&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) );</span></span></code></pre></div><p>如果我们希望在 b 节点截获事件后就不再传递事件，可以通过调用 <code>event.propagationStopped = true</code> 函数来完成。代码实现示例如下：</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 节点 b 的组件脚本中</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.node.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">on</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;foobar&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">event</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MyEvent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  event.propagationStopped </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre></div><blockquote><p><strong>注意</strong>：在派发用户自定义事件的时候，请不要直接创建 <code>cc</code> 内的 <code>Event</code> 对象，因为它是一个抽象类。</p></blockquote><p>如果希望将事件注册在捕获阶段，可以给 <code>on</code> 接口传递第四个参数，例如：</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 节点 a 的组件脚本中</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.node.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">on</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;foobar&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, callback, target, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div><h2 id="事件对象" tabindex="-1">事件对象 <a class="header-anchor" href="#事件对象" aria-label="Permalink to &quot;事件对象&quot;">​</a></h2><p>在事件监听回调中，开发者会接收到一个 Event 类型的事件对象 event，<code>propagationStopped</code> 就是 Event 的标准 API，其它重要的 API 包含：</p><table><thead><tr><th style="text-align:left;">API 名</th><th style="text-align:left;">类型</th><th style="text-align:left;">意义</th></tr></thead><tbody><tr><td style="text-align:left;"><strong>type</strong></td><td style="text-align:left;">String</td><td style="text-align:left;">事件的类型（事件名）。</td></tr><tr><td style="text-align:left;"><strong>target</strong></td><td style="text-align:left;">Node</td><td style="text-align:left;">接收到事件的原始对象。</td></tr><tr><td style="text-align:left;"><strong>currentTarget</strong></td><td style="text-align:left;">Node</td><td style="text-align:left;">接收到事件的当前对象，事件在冒泡阶段当前对象可能与原始对象不同。</td></tr><tr><td style="text-align:left;"><strong>getType</strong></td><td style="text-align:left;">Function</td><td style="text-align:left;">获取事件的类型。</td></tr><tr><td style="text-align:left;"><strong>propagationStopped</strong></td><td style="text-align:left;">Boolean</td><td style="text-align:left;">是否停止传递当前事件。</td></tr><tr><td style="text-align:left;"><strong>propagationImmediateStopped</strong></td><td style="text-align:left;">Boolean</td><td style="text-align:left;">是否立即停止当前事件的传递，事件甚至不会被分派到所连接的当前目标。</td></tr></tbody></table><h2 id="触摸事件的传递" tabindex="-1">触摸事件的传递 <a class="header-anchor" href="#触摸事件的传递" aria-label="Permalink to &quot;触摸事件的传递&quot;">​</a></h2><p>如上所述，注册在 <code>Node</code> 上的触摸事件，引擎内部就是通过 <code>dispatchEvent</code> 接口派发的。下面我们将介绍触摸事件在 <strong>目标</strong> 和 <strong>冒泡</strong> 阶段的传递顺序。</p><h3 id="触摸事件冒泡" tabindex="-1">触摸事件冒泡 <a class="header-anchor" href="#触摸事件冒泡" aria-label="Permalink to &quot;触摸事件冒泡&quot;">​</a></h3><p>触摸事件支持节点树的事件冒泡，以下图为例：</p><p><img src="`+n+'" alt="propagation"></p><p>在上图的场景中，假设 A 节点拥有一个子节点 B，B 拥有一个子节点 C。开发者对 A、B、C 节点都监听了触摸事件（以下的示例默认节点都监听了触摸事件）。</p><p>当鼠标或手指在 C 节点区域内按下时，事件将首先在 C 节点触发，C 节点监听器接收到事件（该阶段为目标阶段）；接着 C 节点会将事件向其父节点 B 传递这个事件，B 节点的监听器将会接收到事件；同理 B 节点会将事件传递给父节点 A 。这就是最基本的事件冒泡过程。</p><blockquote><p><strong>注意</strong>：虽然触点可能不在 A、B 节点区域内，但 A、B 节点也能触发触摸事件，这是通过子节点 C 的触摸事件冒泡机制传递过来的。在触摸事件冒泡的过程中不会有触摸检测。</p></blockquote><p>触摸事件的冒泡过程与普通事件的冒泡过程并没有区别。所以，调用 <code>event.propagationStopped = true</code> 便可主动停止触摸事件的冒泡过程。</p><h3 id="同级节点间的触点归属问题" tabindex="-1">同级节点间的触点归属问题 <a class="header-anchor" href="#同级节点间的触点归属问题" aria-label="Permalink to &quot;同级节点间的触点归属问题&quot;">​</a></h3><p>同级节点间，触点归属于处于顶层的节点。假设上图中 B、C 为同级节点，C 节点部分覆盖在 B 节点之上。这时候如果 C 节点接收到触摸事件，那么表示触点归属于 C 节点，这意味着同级节点 B 就不会再接收到触摸事件了，即使触点同时也在 B 节点内。</p><p>此时如果 C 节点还存在父节点，那么通过事件冒泡机制 C 节点还可以将触摸事件传递给父节点。</p><p>在 v3.4.0 中，我们支持了 <strong>事件穿透派发</strong> 功能。在上述同级节点的例子中，如果需要把事件穿透也派发给 B 节点，则可以通过调用 <code>event.preventSwallow = true</code> 来阻止事件被 C 节点吞噬。</p><blockquote><p><strong>注意</strong>：如果要让 TOUCH END 事件可穿透的话，对应的 TOUCH START 事件也需要设置为可穿透。事件的穿透派发会降低事件派发的效率，请谨慎使用。</p></blockquote><h3 id="不同-canvas-的触点归属问题" tabindex="-1">不同 Canvas 的触点归属问题 <a class="header-anchor" href="#不同-canvas-的触点归属问题" aria-label="Permalink to &quot;不同 Canvas 的触点归属问题&quot;">​</a></h3><p>不同 Canvas 之间的触点拦截是根据节点优先级（可在 Canvas 节点默认自带的 Camera 节点的 <code>priority</code> 属性中设置）决定的。在下图的场景中，左侧节点树里的节点 Canvas 1-5 对应着右侧场景中的图片 priority 1-5。可以看出，即使节点 Canvas 3、4、5 在节点树里并没有按照顺序排列，但根据 Canvas 上的优先级（<code>priority</code>）关系，触点的响应先后顺序仍然是 <strong>Canvas 5 -&gt; Canvas 4 -&gt; Canvas 3 -&gt; Canvas 2 -&gt; Canvas 1</strong>。只有在优先级相同的情况下，Canvas 之间的排序才是按照节点树的先后顺序进行。</p><p><img src="'+l+'" alt="multi-canvas"></p><h3 id="将触摸或鼠标事件注册在捕获阶段" tabindex="-1">将触摸或鼠标事件注册在捕获阶段 <a class="header-anchor" href="#将触摸或鼠标事件注册在捕获阶段" aria-label="Permalink to &quot;将触摸或鼠标事件注册在捕获阶段&quot;">​</a></h3><p>有时候我们需要父节点的触摸或鼠标事件先于它的任何子节点派发，比如 <strong>ScrollView</strong> 组件就是这样设计的。这时候事件冒泡已经不能满足我们的需求了，需要将父节点的事件注册在捕获阶段。</p><p>要实现这个需求，可以在给 node 注册触摸或鼠标事件时，传入第四个参数 <code>true</code>，表示 <code>useCapture</code>。代码示例如下：</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.node.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">on</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Node.EventType.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">TOUCH_START</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.onTouchStartCallback, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div><p>当节点触发 <code>Node.EventType.TOUCH_START</code> 事件时，会先将 <code>Node.EventType.TOUCH_START</code> 事件派发给所有注册在捕获阶段的父节点监听器，然后派发给节点自身的监听器，最后才到了事件冒泡阶段。</p><h3 id="事件拦截" tabindex="-1">事件拦截 <a class="header-anchor" href="#事件拦截" aria-label="Permalink to &quot;事件拦截&quot;">​</a></h3><p>正常的事件会按照上文说明的方式去派发。但是如果节点身上带有 <code>Button</code>、<code>Toggle</code> 或者 <code>BlockInputEvents</code> 这几个组件的话，会停止事件冒泡。</p><p>例如下图，图中有两个按钮，分别是 Canvas 0 下的 priority 1 和 Canvas 1 下的 priority 2。如果点击两个按钮的交汇处，也就是图中的蓝色区域，会出现按钮 priority 2 成功接收到了触点事件，而按钮 priority 1 则没有。<br>这是因为按上文的事件接收规则，按钮 priority 2 优先接收到了触摸事件，并且对事件进行了拦截（<code>event.propagationStopped = true</code>），以防止事件穿透。如果是非按钮节点，也可以通过添加 <code>BlockInputEvents</code> 组件来对事件进行拦截，防止穿透。</p><blockquote><p><strong>注意</strong>：按钮 priority 1 和 priority 2 分别在 Canvas 0 和 Canvas 1 节点下，两个按钮并不是同级节点。</p></blockquote><p><img src="'+h+'" alt="events-block"></p><h2 id="触摸事件举例" tabindex="-1">触摸事件举例 <a class="header-anchor" href="#触摸事件举例" aria-label="Permalink to &quot;触摸事件举例&quot;">​</a></h2><p>以下图举例，总结下触摸事件的传递机制。图中有 A、B、C、D 四个节点，其中 A、B 为同级节点。具体层级关系如下：</p><p><img src="'+p+`" alt="example"></p><ol><li>若触点在 A、B 的重叠区域内，此时 B 接收不到触摸事件，事件的传递顺序是 A -&gt; C -&gt; D</li><li>若触点在 B 节点内（可见的绿色区域），则事件的传递顺序是 B -&gt; C -&gt; D</li><li>若触点在 C 节点内，则事件的传递顺序是 C -&gt; D</li><li>若以第 2 种情况为前提，同时 C D 节点的触摸事件注册在捕获阶段，则事件的传递顺序是 D -&gt; C -&gt; B</li></ol><h2 id="node-的其它事件" tabindex="-1">Node 的其它事件 <a class="header-anchor" href="#node-的其它事件" aria-label="Permalink to &quot;Node 的其它事件&quot;">​</a></h2><p>所有的 <code>Node</code> 内置事件都可以通过 <code>Node.EventType</code> 获取事件名。</p><h3 id="_3d-节点事件" tabindex="-1">3D 节点事件 <a class="header-anchor" href="#_3d-节点事件" aria-label="Permalink to &quot;3D 节点事件&quot;">​</a></h3><table><thead><tr><th style="text-align:left;">枚举对象定义</th><th style="text-align:left;">事件触发的时机</th></tr></thead><tbody><tr><td style="text-align:left;"><strong>TRANSFORM_CHANGED</strong></td><td style="text-align:left;">当变换属性修改时，会派发一个枚举值 <code>TransformBit</code>，根据枚举值定义修改的变换。</td></tr></tbody></table><p>变换枚举值定义：</p><table><thead><tr><th style="text-align:left;">枚举值含义</th><th style="text-align:left;">对应的变换</th></tr></thead><tbody><tr><td style="text-align:left;"><strong>TransformBit.NONE</strong></td><td style="text-align:left;">属性无改变。</td></tr><tr><td style="text-align:left;"><strong>TransformBit.POSITION</strong></td><td style="text-align:left;">节点位置改变。</td></tr><tr><td style="text-align:left;"><strong>TransformBit.ROTATION</strong></td><td style="text-align:left;">节点旋转改变。</td></tr><tr><td style="text-align:left;"><strong>TransformBit.SCALE</strong></td><td style="text-align:left;">节点缩放改变。</td></tr><tr><td style="text-align:left;"><strong>TransformBit.RS</strong></td><td style="text-align:left;">节点旋转及缩放改变。</td></tr><tr><td style="text-align:left;"><strong>TransformBit.TRS</strong></td><td style="text-align:left;">节点平移，旋转及缩放都改变。</td></tr></tbody></table><h3 id="_2d-节点事件" tabindex="-1">2D 节点事件 <a class="header-anchor" href="#_2d-节点事件" aria-label="Permalink to &quot;2D 节点事件&quot;">​</a></h3><table><thead><tr><th style="text-align:left;">枚举对象定义</th><th style="text-align:left;">事件触发的时机</th></tr></thead><tbody><tr><td style="text-align:left;"><strong>SIZE_CHANGED</strong></td><td style="text-align:left;">当宽高属性修改时。宽高属性位于 <code>UITransform</code> 组件上。</td></tr><tr><td style="text-align:left;"><strong>ANCHOR_CHANGED</strong></td><td style="text-align:left;">当锚点属性修改时。锚点属性位于 <code>UITransform</code> 组件上。</td></tr><tr><td style="text-align:left;"><strong>COLOR_CHANGED</strong></td><td style="text-align:left;">当颜色属性修改时。颜色属性位于 UI 渲染组件上。</td></tr><tr><td style="text-align:left;"><strong>CHILD_ADDED</strong></td><td style="text-align:left;">添加子节点时。</td></tr><tr><td style="text-align:left;"><strong>CHILD_REMOVED</strong></td><td style="text-align:left;">移除子节点时。</td></tr><tr><td style="text-align:left;"><strong>PARENT_CHANGED</strong></td><td style="text-align:left;">父节点改变时。</td></tr><tr><td style="text-align:left;"><strong>SIBLING_ORDER_CHANGED</strong></td><td style="text-align:left;">兄弟节点顺序改变时。</td></tr><tr><td style="text-align:left;"><strong>SCENE_CHANGED_FOR_PERSISTS</strong></td><td style="text-align:left;">改变常驻节点所在场景时。</td></tr><tr><td style="text-align:left;"><strong>NODE_DESTROYED</strong></td><td style="text-align:left;">节点销毁时。</td></tr><tr><td style="text-align:left;"><strong>LAYER_CHANGED</strong></td><td style="text-align:left;"><code>layer</code> 属性改变时。</td></tr><tr><td style="text-align:left;"><strong>ACTIVE_IN_HIERARCHY_CHANGED</strong></td><td style="text-align:left;"><code>activeInHierarchy</code> 属性改变时。</td></tr></tbody></table><h2 id="多点触摸事件" tabindex="-1">多点触摸事件 <a class="header-anchor" href="#多点触摸事件" aria-label="Permalink to &quot;多点触摸事件&quot;">​</a></h2><p>引擎有多点触摸事件的屏蔽开关，多点触摸事件默认为开启状态。对于不需要多点触摸的项目，可以通过以下代码关闭多点触摸：</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">macro.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">ENABLE_MULTI_TOUCH</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre></div><p>或者也可以通过 Creator 顶部菜单栏的 <strong>项目 -&gt; 项目设置 -&gt; Macro Config</strong> 进行配置，去掉<strong>ENABLE_MULTI_TOUCH</strong> 属性的勾选。</p><h2 id="暂停或恢复节点系统事件" tabindex="-1">暂停或恢复节点系统事件 <a class="header-anchor" href="#暂停或恢复节点系统事件" aria-label="Permalink to &quot;暂停或恢复节点系统事件&quot;">​</a></h2><p>暂停节点系统事件，代码示例如下：</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 暂停当前节点上注册的所有节点系统事件，节点系统事件包含触摸和鼠标事件。</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 如果传递参数 true，那么这个 API 将暂停本节点和它的所有子节点上的节点系统事件。</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// example</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.node.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">pauseSystemEvents</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span></code></pre></div><p>恢复节点系统事件，代码示例如下：</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 恢复当前节点上注册的所有节点系统事件，节点系统事件包含触摸和鼠标事件。</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 如果传递参数 true，那么这个 API 将恢复本节点和它的所有子节点上的节点系统事件。</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// example</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.node.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">resumeSystemEvents</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span></code></pre></div>`,80),o=[r];function k(g,E,c,y,C,v){return a(),s("div",null,o)}const f=t(d,[["render",k]]);export{u as __pageData,f as default};
