import{_ as s,v as n,b as o,R as a}from"./chunks/framework.5ffcbaff.js";const l="/docs/cocos/assets/setting.cd7c31a5.png",t="/docs/cocos/assets/forward-pipeline.7f823a26.png",p="/docs/cocos/assets/DeferredPipeline.1e12e51c.png",e="/docs/cocos/assets/BloomEnable.1ba82459.png",m=JSON.parse('{"title":"内置渲染管线","description":"","frontmatter":{},"headers":[],"relativePath":"zh/manual/render-pipeline/builtin-pipeline.md","filePath":"zh/manual/render-pipeline/builtin-pipeline.md"}'),r={name:"zh/manual/render-pipeline/builtin-pipeline.md"},c=a('<h1 id="内置渲染管线" tabindex="-1">内置渲染管线 <a class="header-anchor" href="#内置渲染管线" aria-label="Permalink to &quot;内置渲染管线&quot;">​</a></h1><p>Cocos Creator 3.1 的内置渲染管线包括 <strong>builtin-forward</strong>（前向渲染管线）和 <strong>builtin-deferred</strong>（延迟渲染管线）。渲染管线可通过编辑器主菜单中的 <strong>项目 -&gt; 项目设置 -&gt; 项目数据 -&gt; 渲染管线</strong> 进行设置，设置完成之后 <strong>重启编辑器</strong> 即可生效。</p><p><img src="'+l+'" alt="setting"></p><h2 id="前向渲染管线" tabindex="-1">前向渲染管线 <a class="header-anchor" href="#前向渲染管线" aria-label="Permalink to &quot;前向渲染管线&quot;">​</a></h2><p>引擎默认使用 <strong>前向渲染管线</strong>，前向渲染管线的执行流程如下图所示：</p><img src="'+t+'" width="760" height="296"><p>前向渲染主要包括 <strong>ShadowFlow</strong> 和 <strong>ForwardFlow</strong> 两个阶段：</p><ul><li><strong>ShadowFlow</strong> 中包含一个 <strong>ShadowStage</strong> 会预先对场景中需要投射阴影的物体进行阴影贴图的绘制。</li><li><strong>ForwardFlow</strong> 包含一个 <strong>ForwardStage</strong>，会对场景中所有物体按照 <strong>非透明 -&gt; 光照 -&gt; 透明 -&gt; UI</strong> 的顺序依次进行绘制。在计算光照时，每个物体都会与所有光照进行计算确定是否照射到该物体，照射到该物体的光照将会执行绘制并进行光照计算，目前场景中只支持一个平行光，可接受的最大光照数量为 16。</li></ul><h2 id="延迟渲染管线" tabindex="-1">延迟渲染管线 <a class="header-anchor" href="#延迟渲染管线" aria-label="Permalink to &quot;延迟渲染管线&quot;">​</a></h2><p>目前引擎提供了试验版本的内置 <strong>延迟渲染管线</strong>，对于光照数量比较多的项目可以使用 <strong>延迟渲染管线</strong> 来缓解光照计算的压力。延迟管线的执行流程如下图所示：</p><img src="'+p+'" width="760" height="350"><p>内置的延迟渲染管线主要包括 <strong>ShadowFlow</strong> 和 <strong>MainFlow</strong> 两个过程：</p><ol><li><p><strong>ShadowFlow</strong> 与前向渲染一致，用于预先进行阴影贴图的绘制。</p></li><li><p><strong>MainFlow</strong> 包含了 <strong>GBufferStage</strong>、<strong>LightingStage</strong>、<strong>BloomStage</strong> 和 <strong>PostProcessStage</strong> 四个阶段：</p><ul><li><strong>GbufferStage</strong> 会对场景中的非透明物体进行绘制；</li><li>然后 <strong>LightingStage</strong> 会对输出到 <strong>GBuffer</strong> 中的非透明物体信息进行基于屏幕空间的光照计算，再绘制半透明物体。如果有非透明物体并且设备支持 ComputeShader，还会进行 SSPR 的资源收集与绘制；</li><li>若还开启了 Bloom 效果，<strong>BloomStage</strong> 会对已经经过 <strong>LightingStage</strong> 处理后的图像进行 Bloom 后处理；</li><li>最后 <strong>PostProcessStage</strong> 会把 <strong>BloomStage</strong>/<strong>LightingStage</strong> 输出的全屏图像绘制到主屏幕中，再进行 UI 的绘制。</li></ul></li></ol><p>开启 Bloom 有以下两种方式：</p><ol><li><p>点击 Creator 顶部菜单栏中的 <strong>项目 -&gt; 项目设置 -&gt; Macro Configurations</strong>，然后勾选 <strong>ENABLE_BLOOM</strong> 即可开启：</p><img src="'+e+`" width="760" height="510"></li><li><p>通过代码开启，示例如下：</p></li></ol><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;">@</span><span style="color:#82AAFF;">ccclass</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">BloomSwitch</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">export</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">class</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">BloomSwitch</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">extends</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Component</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#F07178;">bloomEnabled</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">boolean</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#FF9CAC;">false</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#F07178;">setupPipeline</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">        (</span><span style="color:#A6ACCD;">director</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">root</span><span style="color:#89DDFF;">?.</span><span style="color:#A6ACCD;">pipeline</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;font-style:italic;">as</span><span style="color:#F07178;"> </span><span style="color:#FFCB6B;">DeferredPipeline</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">bloomEnabled</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">this.</span><span style="color:#A6ACCD;">bloomEnabled</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#F07178;">switchEnable</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">toggle</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Toggle</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#F07178;"> (</span><span style="color:#A6ACCD;">toggle</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">isChecked</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">!==</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">this.</span><span style="color:#A6ACCD;">bloomEnabled</span><span style="color:#F07178;">) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">            </span><span style="color:#89DDFF;">this.</span><span style="color:#A6ACCD;">bloomEnabled</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">toggle</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">isChecked</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">            </span><span style="color:#89DDFF;">this.</span><span style="color:#82AAFF;">setupPipeline</span><span style="color:#F07178;">()</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span></code></pre></div><p>延迟渲染管线依赖 GPU 的 <strong>Multiple Render Targets</strong> 特性用于绘制 <strong>GBuffer</strong>，目前大部分移动平台应该都支持。WebGL1.0 环境下可以使用 <strong>WEBGL_draw_buffers</strong> 扩展支持，不过部分 WebGL1.0 平台可能不支持该扩展，那么就不能使用延迟渲染管线。</p><p>另外延迟渲染管线对于 <strong>卡通材质</strong> 无法正常进行绘制，比如引擎内置的 <code>builtin-toon</code> 材质。</p><p>引擎内置的渲染管线后续也会不断优化性能，并添加新的特性，为开发者提供更加多元和丰富的渲染特性。</p>`,19),i=[c];function g(F,D,y,C,A,d){return n(),o("div",null,i)}const u=s(r,[["render",g]]);export{m as __pageData,u as default};
