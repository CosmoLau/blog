import{_ as e,c as s,o as i,a4 as o}from"./chunks/framework.uQk9_EO2.js";const m=JSON.parse('{"title":"Module Specification","description":"","frontmatter":{},"headers":[],"relativePath":"en/scripting/modules/spec.md","filePath":"en/scripting/modules/spec.md","lastUpdated":1712305443000}'),t={name:"en/scripting/modules/spec.md"},a=o(`<h1 id="module-specification" tabindex="-1">Module Specification <a class="header-anchor" href="#module-specification" aria-label="Permalink to &quot;Module Specification&quot;">​</a></h1><h2 id="module-format" tabindex="-1">Module Format <a class="header-anchor" href="#module-format" aria-label="Permalink to &quot;Module Format&quot;">​</a></h2><p>This section describes how Cocos Creator determines the format of a module.</p><p>All the functionalities provided by the Cocos Creator engine are in the form of ESM modules, see <a href="./">engine modules</a>.</p><p>Files in the project resources directory ending in <code>.ts</code>. For example <code>assets/scripts/foo.ts</code>.</p><p>For any other module formats, Cocos Creator chooses rules similar to Node.js to <a href="https://nodejs.org/api/packages.html#packages_determining_module_system" target="_blank" rel="noreferrer">identify</a>. Specifically, the following files will be considered in ESM format:</p><ul><li><p>Files ending in <code>.mjs</code>.</p></li><li><p>Files ending in <code>.js</code> and whose nearest parent <code>package.json</code> file contains a top-level <code>&quot;type&quot;</code> field with a value of <code>&quot;module&quot;</code>.</p></li></ul><p>The rest of the files will be treated as CommonJS module format, which includes</p><ul><li><p>Files ending in <code>.cjs</code>.</p></li><li><p>Files ending in <code>.js</code> and whose nearest <code>package.json</code> file contains a top-level <code>&quot;type&quot;</code> field with a value of <code>&quot;commonjs&quot;</code>.</p></li><li><p>Files ending in <code>.js</code> that do not fall under the above conditions.</p></li></ul><h2 id="module-descriptors-and-module-parsing" tabindex="-1">Module Descriptors and Module Parsing <a class="header-anchor" href="#module-descriptors-and-module-parsing" aria-label="Permalink to &quot;Module Descriptors and Module Parsing&quot;">​</a></h2><p>In an ESM module, interaction with the target module is done through standard import and export statements, e.g.</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { Foo } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;. /foo&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { Bar } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;. /bar&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre></div><p>The string after the keyword <code>from</code> in the import/export statement is called a <strong>module specifier</strong>. The module specifier can also appear as a parameter in the dynamic import expression <code>import()</code>.</p><p>The module specifier is used to specify the target module, and the process of resolving the target module URL from the module specifier is called <strong>module resolution</strong>.</p><p>Cocos Creator supports three types of module specifiers:</p><ul><li><p><strong>relative specifier</strong>: a specifier like <code>&#39;./foo&#39;</code>, <code>&#39;../bar&#39;</code> starting with <code>&#39;./&#39;</code> and <code>&#39;../&#39;</code>.</p></li><li><p><strong>absolute specifier</strong>: a specifier that specifies a URL. For example: <code>foo:/bar</code>.</p></li><li><p><strong>bare specifier</strong>: a specifier like <code>foo</code> or <code>foo/bar</code> that is neither a URL nor a relative specifier.</p></li></ul><h3 id="relative-specifiers" tabindex="-1">Relative Specifiers <a class="header-anchor" href="#relative-specifiers" aria-label="Permalink to &quot;Relative Specifiers&quot;">​</a></h3><p>Relative specifiers take the URL of the current module as the base URL and use the relative specifier as input to resolve the URL of the target module.</p><p>For example, for the module <code>project path/assets/scripts/utils/foo</code>, <code>&#39;./bar&#39;</code> will be parsed as <code>project path/assets/scripts/utils/bar</code> in the same directory; <code>&#39;../baz&#39;</code> will be parsed as <code>project path/assets/scripts/baz</code> in the upper directory.</p><h3 id="absolute-specifiers" tabindex="-1">Absolute Specifiers <a class="header-anchor" href="#absolute-specifiers" aria-label="Permalink to &quot;Absolute Specifiers&quot;">​</a></h3><p>The absolute specifier directly specifies the URL of the target module.</p><p>Cocos Creator currently only supports file protocol URLs, but since the file path specified in the file URL is an absolute path, it is rarely used.</p><blockquote><p><strong>Note</strong>: in Node.js, one way to access Node.js built-in modules is through <code>node:</code> protocol URLs, e.g.: <code>node:fs</code>. Cocos Creator parses all requests for access to Node.js built-in modules as <code>node:</code> URL requests. For example, <code>&#39;fs&#39;</code> in <code>import fs from &#39;fs&#39;</code> will resolve to <code>node:fs</code>. However, Cocos Creator does not support Node.js built-in modules, which means that it does not support the <code>node:</code> protocol. Therefore, a loading error will occur. This error may be encountered when using modules in npm.</p></blockquote><h3 id="bare-specifiers" tabindex="-1">Bare Specifiers <a class="header-anchor" href="#bare-specifiers" aria-label="Permalink to &quot;Bare Specifiers&quot;">​</a></h3><p>Currently, Cocos Creator will apply <a href="./import-map">Import Maps (experimental)</a> and <a href="https://nodejs.org/api/esm.html#esm_resolver_algorithm_specification" target="_blank" rel="noreferrer">Node.js module parsing algorithm</a> for bare specifiers.</p><blockquote><p>This includes parsing of npm modules.</p></blockquote><h4 id="conditional-exports" tabindex="-1">Conditional exports <a class="header-anchor" href="#conditional-exports" aria-label="Permalink to &quot;Conditional exports&quot;">​</a></h4><p>In the <strong>Node.js</strong> module parsing algorithm, the <a href="https://nodejs.org/api/packages.html#packages_conditional_exports" target="_blank" rel="noreferrer">conditional export</a> feature of packages is used to map the subpaths in a package based on some conditions. Similar to <strong>Node.js</strong>, Cocos Creator implements built-in conditions <code>import</code> and <code>default</code>, but not conditions <code>require</code> and <code>node</code>.</p><p>Developers can specify <strong>additional</strong> conditions via the <strong>Export conditions</strong> option in the editor&#39;s main menu <strong>Project -&gt; Project Settings -&gt; Scripting</strong>, which defaults to <code>browser</code>. Multiple additional conditions can be specified using <strong>commas</strong> as separators, e.g. <code>browser, bar</code>.</p><p>If the <strong>Export conditions</strong> option uses the default value <code>browser</code>, when the <code>package.json</code> of an npm package <code>foo</code> contains the following configuration:</p><div class="language-json vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">   &quot;exports&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">      &quot;.&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">         &quot;browser&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;./dist/browser-main.mjs&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">         &quot;import&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;./dist/main.mjs&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p><code>&quot;foo&quot;</code> will resolve to the module with path <code>dist/browser-main.mjs</code> in the package.</p><blockquote><p>The mapping configuration is done in <a href="https://www.npmjs.com/package/colyseus" target="_blank" rel="noreferrer">Multiplayer Framework Colyseus for Node.js</a> for the <code>browser</code> condition.</p></blockquote><p>If the <strong>Export conditions</strong> option is empty, it means that no additional conditions are specified, and <code>&quot;foo&quot;</code> in the above example will resolve to a module with path <code>dist/main.mjs</code> in the package.</p><h3 id="suffixes-and-directory-import" tabindex="-1">Suffixes and Directory Import <a class="header-anchor" href="#suffixes-and-directory-import" aria-label="Permalink to &quot;Suffixes and Directory Import&quot;">​</a></h3><p>Cocos Creator&#39;s requirements for module suffixes in module specifiers are more web-oriented -- suffixes must be specified and Node.js-style directory import is not supported. However, for historical reasons and some existing restrictions, TypeScript modules do not allow suffixes and support Node.js-style directory import. Specifically:</p><p>When the target module file has the suffix <code>.js</code>, <code>.mjs</code>, the suffix <strong>must be specified</strong> in the module specifier: <code>.js</code>, <code>.mjs</code>.</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;. /foo.mjs&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// correct</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;. /foo&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// error: the specified module cannot be found</span></span></code></pre></div><p>Node.js-style directory import is not supported:</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;. /foo/index.mjs&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// correct</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;. /foo&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// error: module cannot be found.</span></span></code></pre></div><blockquote><p>This suffix requirement applies to both relative and absolute specifiers along with the restriction on directory import. For requirements in bare specifiers please refer to the Node.js module parsing algorithm.</p></blockquote><p>However, when the target module file has a suffix of <code>.ts</code>, the suffix is <strong>not allowed to be specified</strong> in the module specifier:</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;. /foo&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// correct: parsed as the \`foo.ts\` module in the same directory</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;. /foo.ts&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// error: the specified module cannot be found</span></span></code></pre></div><p>On the other hand, Node.js-style directory import is supported:</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;. /foo&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// correct: parsed as the \`foo/index.ts\` module</span></span></code></pre></div><blockquote><p><strong>Notes</strong>:</p><ol><li>Cocos Creator supports the Web platform. Implementing complex module parsing algorithms like Node.js on the Web platform is expensive, and the client and server cannot try different suffixes and file paths with frequent communication between them.</li><li>Even if such complex parsing could be done at the build stage with some post-processing tools, it would result in inconsistent algorithms for static import parsing (via <code>import</code> statements) and dynamic import parsing (via <code>import()</code> expressions). Therefore, specify the full file path in the code for the choice of module parsing algorithm.</li><li>However, this cannot be restricted completely, since TypeScript currently doesn&#39;t allow the suffix <code>.ts</code> to be specified in the specifier. And TypeScript does not yet support auto-completion of specific target suffixes. With these limitations, it&#39;s hard to have it both ways, but we&#39;re still watching to see if these conditions improve in the future.</li></ol></blockquote><h3 id="the-browser-field-is-not-supported" tabindex="-1">The <code>browser</code> Field is not Supported <a class="header-anchor" href="#the-browser-field-is-not-supported" aria-label="Permalink to &quot;The \`browser\` Field is not Supported&quot;">​</a></h3><p>Some npm packages have <code>browser</code> fields documented in the manifest file <code>package.json</code>, e.g.: <a href="https://github.com/Stuk/jszip" target="_blank" rel="noreferrer">JSZip</a>. The <code>browser</code> field is used to specify a module parsing method specific to the package when it is in a non-Node.js environment, which allows some Node.js-specific modules in the package to be replaced with modules that can be used in the Web. Although Cocos Creator <strong>does not support this field</strong>, if you have the ability to edit npm packages, Cocos Creator recommends using <a href="https://nodejs.org/api/packages.html#packages_conditional_exports" target="_blank" rel="noreferrer">conditionalized export</a> and <a href="https://nodejs.org/api/packages.html#packages_subpath_imports" target="_blank" rel="noreferrer">subpath import</a> instead of the <code>browser</code> field.</p><p>Otherwise, the target library can be used in a non-npm way. For example, copying modules from the target library that are specifically made for non-Node.js environments into the project and importing them via relative paths.</p><h2 id="commonjs-module-parsing" tabindex="-1">CommonJS Module Parsing <a class="header-anchor" href="#commonjs-module-parsing" aria-label="Permalink to &quot;CommonJS Module Parsing&quot;">​</a></h2><p>In CommonJS modules, Cocos Creator applies the <a href="https://nodejs.org/api/modules.html#modules_all_together" target="_blank" rel="noreferrer">Node.js CommonJS module parsing algorithm</a>.</p><h2 id="module-format-interaction" tabindex="-1">Module Format Interaction <a class="header-anchor" href="#module-format-interaction" aria-label="Permalink to &quot;Module Format Interaction&quot;">​</a></h2><p>Cocos Creator allows importing CommonJS modules in ESM modules.</p><p>When importing a CommonJS module from an ESM module, the <code>module.exports</code> object of the CommonJS module will be used as the default export for the ESM module:</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { log } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;cc&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">default</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> as</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> cjs } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;cjs&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Another way to write the above import statement:</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> cjsSugar </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;cjs&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(cjs);</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(cjs </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> cjsSugar);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Print.</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// &lt;module.exports&gt;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// true</span></span></code></pre></div><p>The CommonJS module&#39;s <a href="https://tc39.es/ecma262/#sec-module-namespace-objects" target="_blank" rel="noreferrer">ECMAScript module namespace</a> indicates that it is a namespace containing a <code>default</code> export, where the <code>default</code> export points to the value of <code>module.exports</code> of the CommonJS module.</p><p>This <a href="https://tc39.es/ecma262/#module-namespace-exotic-object" target="_blank" rel="noreferrer">module namespace foreign object</a> can be observed by <code>import * as m from &#39;cjs&#39;</code>.</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> *</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> as</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> m </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;cjs&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(m);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Print:</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// [Module] { default: &lt;module.exports&gt; }</span></span></code></pre></div><h2 id="cocos-creator-esm-parsing-algorithm-public-notice" tabindex="-1">Cocos Creator ESM Parsing Algorithm Public Notice <a class="header-anchor" href="#cocos-creator-esm-parsing-algorithm-public-notice" aria-label="Permalink to &quot;Cocos Creator ESM Parsing Algorithm Public Notice&quot;">​</a></h2><p>The algorithm used by Cocos Creator to parse ESM module specifiers is given by the following <code>CREATOR_ESM_RESOLVE</code> method. It returns the result of parsing the module specifier from the current URL.</p><p>The <a href="https://nodejs.org/api/esm.html#esm_resolution_algorithm" target="_blank" rel="noreferrer">external algorithm</a> is referenced in the parsing algorithm specification.</p><h3 id="parsing-algorithm-specification" tabindex="-1">Parsing Algorithm Specification <a class="header-anchor" href="#parsing-algorithm-specification" aria-label="Permalink to &quot;Parsing Algorithm Specification&quot;">​</a></h3><p><code>CREATOR_ESM_RESOLVE(specifier, parentURL)</code></p><ol><li>Let <code>resolved</code> be the result of <code>ESM_RESOLVE(specifier, parentURL)</code>.</li><li>If both <code>parentURL</code> and <code>resolved</code> are under project assets directory, then <ol><li>Let <code>extensionLessResolved</code> be the result of <code>TRY_EXTENSION_LESS_RESOLVE(resolved)</code>. <ol><li>If <code>extensionLessResolved</code> is not <code>undefined</code>, return <code>extensionLessResolved</code>.</li></ol></li></ol></li><li>Return <code>resolved</code>.</li></ol><p><code>TRY_EXTENSION_LESS_RESOLVE(url)</code></p><ol><li>If the file at <code>url</code> exists, then <ol><li>Return <code>url</code>.</li></ol></li><li>Let <code>baseName</code> be the portion after the last &quot;/&quot; in pathname of <code>url</code>, or whole pathname if it does not contain a &quot;/&quot;.</li><li>If <code>baseName</code> is empty, then <ol><li>Return <code>undefined</code>.</li></ol></li><li>Let <code>resolved</code> be the result URL resolution of &quot;./&quot; concatenated with <code>baseName</code> and <code>.ts</code>, relative to parentURL. <ol><li>If the file at <code>resolved</code> exists, then</li><li>Return <code>resolved</code>.</li></ol></li><li>Let <code>resolved</code> be the result URL resolution of &quot;./&quot; concatenated with <code>baseName</code> and <code>/index.ts</code>, relative to parentURL. <ol><li>If the file at <code>resolved</code> exists, then</li><li>Return <code>resolved</code>.</li></ol></li><li>Return <code>undefined</code>.</li></ol>`,66),n=[a];function r(l,p,d,h,c,u){return i(),s("div",null,n)}const g=e(t,[["render",r]]);export{m as __pageData,g as default};
