import{_ as s,c as i,o as a,a5 as n}from"./chunks/framework.CqnjdYks.js";const e="/docs/cocos/assets/cp-render-graph-1.C1YQAlGh.png",t="/docs/cocos/assets/cp-render-graph-2.BmjqGvSc.png",p="/docs/cocos/assets/cp-raster-pass.BJV15oH9.png",l="/docs/cocos/assets/cp-compute-pass.D0lW3WLN.png",h="/docs/cocos/assets/cp-copy-pass.calDGw4E.png",r="/docs/cocos/assets/cp-raster-view.CluP7aTj.png",k="/docs/cocos/assets/cp-compute-view.DlH4ZM5d.png",o="/docs/cocos/assets/cp-add-raster-view.BIAVRw2i.png",d="/docs/cocos/assets/cp-add-compute-view.5DMu6208.png",E="/docs/cocos/assets/cp-add-raster-queue.D1cplyNh.png",g="/docs/cocos/assets/cp-raster-queue.DPFHZB63.png",c="/docs/cocos/assets/cp-add-compute-queue.lb8799Pt.png",y="/docs/cocos/assets/cp-dispatch.DtBcIRv3.png",F="/docs/cocos/assets/cp-scene.CSVhL38p.png",u="/docs/cocos/assets/cp-quad.fcWeKD47.png",m="/docs/cocos/assets/cp-dispatch.DtBcIRv3.png",C="/docs/cocos/assets/cp-setter.RnGIAlaI.png",D="/docs/cocos/assets/cp-data-structure.CG1o8xxE.png",A="/docs/cocos/assets/cp-feature-enable.Dp91Jdnk.png",P="/docs/cocos/assets/cp-pipeline-selection.Bm8E8KUB.png",B="/docs/cocos/assets/postprocessPass.Bu9X6shB.png",R="/docs/cocos/assets/postprocessOutput.ucZ8jX-r.png",w="/docs/cocos/assets/testCustomPipeline.I_5ddPS4.png",_="/docs/cocos/assets/customPipelineBloom.mKuM104W.png",O=JSON.parse('{"title":"自定义渲染管线（实验性质）","description":"","frontmatter":{},"headers":[],"relativePath":"zh/manual/render-pipeline/custom-pipeline.md","filePath":"zh/manual/render-pipeline/custom-pipeline.md"}'),f={name:"zh/manual/render-pipeline/custom-pipeline.md"},b=n('<h1 id="自定义渲染管线-实验性质" tabindex="-1">自定义渲染管线（实验性质） <a class="header-anchor" href="#自定义渲染管线-实验性质" aria-label="Permalink to &quot;自定义渲染管线（实验性质）&quot;">​</a></h1><p>Cocos Creator 3.6中添加了新的 <strong>自定义渲染管线</strong>。</p><p>目前为实验性的前瞻版本，接口、命名尚未稳定，不推荐在正式项目中使用。目前仅支持 Web 端。</p><p><strong>自定义渲染管线</strong> 的接口位于 <code>cocos/core/pipeline/custom/pipeline.ts</code></p><h2 id="概述" tabindex="-1">概述 <a class="header-anchor" href="#概述" aria-label="Permalink to &quot;概述&quot;">​</a></h2><p>通过 <strong>自定义渲染管线</strong>（CustomPipeline），用户可以定制 <strong>渲染通道</strong>（RenderPass），设置输入/输出的 <strong>渲染视图</strong>（RenderView）、以及每个 <strong>渲染通道</strong> 需要绘制的 <strong>渲染内容</strong>（RenderContent）。</p><p><strong>渲染内容</strong> 可以是 <strong>场景</strong>、屏幕 <strong>矩形</strong>，也可以是计算任务的 <strong>分发</strong>（Dispatch），取决于 <strong>渲染通道</strong> 的类型。</p><p><strong>渲染内容</strong> 的绘制顺序，可以通过 <strong>渲染队列</strong>（RenderQueue）进行调整。</p><p><strong>自定义渲染管线</strong> 的【<strong>渲染通道</strong>、<strong>渲染队列</strong>、<strong>渲染内容</strong>】构成一个森林：</p><img src="'+e+'" width="640"><p><strong>自定义渲染管线</strong>的【<strong>渲染通道</strong>、<strong>渲染视图</strong>】构成一个有向无圈图（DAG）：</p><img src="'+t+'" width="640"><p>我们可以层叠（Stack）以上两张图，得到 <strong>渲染流程图</strong>（RenderGraph）。<strong>渲染流程图</strong> 描述了 <strong>自定义渲染管线</strong> 的全部流程，引擎会按照用户定制的流程图进行资源分配、流程优化、渲染执行。</p><h2 id="渲染通道-renderpass" tabindex="-1">渲染通道（RenderPass） <a class="header-anchor" href="#渲染通道-renderpass" aria-label="Permalink to &quot;渲染通道（RenderPass）&quot;">​</a></h2><p><strong>渲染通道</strong> 有三种类型：光栅（Raster）、计算（Compute）、资源（Resource）。</p><p>每种类型会有各自不同的 <strong>渲染通道</strong>。</p><h3 id="光栅类型-raster" tabindex="-1">光栅类型（Raster） <a class="header-anchor" href="#光栅类型-raster" aria-label="Permalink to &quot;光栅类型（Raster）&quot;">​</a></h3><p>光栅类型使用了GPU的光栅化能力（在GraphicsEngine执行）。</p><h4 id="_1-光栅化通道-rasterpass" tabindex="-1">1. <strong>光栅化通道</strong>（RasterPass） <a class="header-anchor" href="#_1-光栅化通道-rasterpass" aria-label="Permalink to &quot;1. **光栅化通道**（RasterPass）&quot;">​</a></h4><img src="'+p+'" width="760"><ul><li><p>width、height为输出渲染目标的分辨率。</p></li><li><p>layoutName为Effect的Stage名字。</p></li><li><p>name为调试（debug）时显示的名字。为空时，系统会赋予默认名字。</p></li></ul><h4 id="_2-光栅化子通道-rastersubpass" tabindex="-1">2. <strong>光栅化子通道</strong>（RasterSubpass） <a class="header-anchor" href="#_2-光栅化子通道-rastersubpass" aria-label="Permalink to &quot;2. **光栅化子通道**（RasterSubpass）&quot;">​</a></h4><p>功能尚未开放。需要GPU分块渲染能力（Tile-based rendering）。</p><h4 id="_3-光栅化展示通道-presentpass" tabindex="-1">3. <strong>光栅化展示通道</strong>（PresentPass） <a class="header-anchor" href="#_3-光栅化展示通道-presentpass" aria-label="Permalink to &quot;3. **光栅化展示通道**（PresentPass）&quot;">​</a></h4><p>将画面渲染至屏幕上。</p><h3 id="计算类型-compute" tabindex="-1">计算类型（Compute） <a class="header-anchor" href="#计算类型-compute" aria-label="Permalink to &quot;计算类型（Compute）&quot;">​</a></h3><p>计算类型使用了GPU的通用计算能力、以及光线追踪能力（可在GraphicsEngine、ComputeEngine执行）。</p><h4 id="_1-计算通道-computepass" tabindex="-1">1. <strong>计算通道</strong>（ComputePass） <a class="header-anchor" href="#_1-计算通道-computepass" aria-label="Permalink to &quot;1. **计算通道**（ComputePass）&quot;">​</a></h4><img src="'+l+'" width="760"><ul><li><p>layoutName为Effect的Pass名字。</p></li><li><p>name为调试（debug）时显示的名字。为空时，系统会赋予默认名字。</p></li></ul><h4 id="_2-光线追踪通道-raytracepass" tabindex="-1">2. <strong>光线追踪通道</strong>（RaytracePass） <a class="header-anchor" href="#_2-光线追踪通道-raytracepass" aria-label="Permalink to &quot;2. **光线追踪通道**（RaytracePass）&quot;">​</a></h4><p>功能尚未开放。需要GPU光线追踪能力。</p><h3 id="资源类型-resource" tabindex="-1">资源类型（Resource） <a class="header-anchor" href="#资源类型-resource" aria-label="Permalink to &quot;资源类型（Resource）&quot;">​</a></h3><p>资源类型使用了 GPU 的资源处理能力（可在GraphicsEngine、ComputeEngine、CopyEngine执行）。</p><h4 id="_1-拷贝通道-copypass" tabindex="-1">1. <strong>拷贝通道</strong>（CopyPass） <a class="header-anchor" href="#_1-拷贝通道-copypass" aria-label="Permalink to &quot;1. **拷贝通道**（CopyPass）&quot;">​</a></h4><p>负责将资源来源（source）拷贝至目标（target），需要资源格式兼容。</p><img src="'+h+'" width="760"><ul><li>name 为调试（debug）时显示的名字。为空时，系统会赋予默认名字。</li></ul><h4 id="_2-移动通道-movepass" tabindex="-1">2. <strong>移动通道</strong>（MovePass） <a class="header-anchor" href="#_2-移动通道-movepass" aria-label="Permalink to &quot;2. **移动通道**（MovePass）&quot;">​</a></h4><p>负责将资源来源（source）移动至目标（target），需要资源格式全同。</p><p>这里的移动是语义上的概念（move semantics）：将来源的变量移动至目标变量，作废来源变量。如果资源因某些原因无法移动（比如资源来源正在被读取），则以拷贝方式实现。</p><p>移动语义用于管线优化，达到减小带宽的目的。如果不清楚如何正确使用<strong>移动通道</strong>，可以用<strong>拷贝通道</strong>替代，不会影响画面表现，调试时较为容易。</p><h2 id="渲染视图-renderview" tabindex="-1">渲染视图（RenderView） <a class="header-anchor" href="#渲染视图-renderview" aria-label="Permalink to &quot;渲染视图（RenderView）&quot;">​</a></h2><p>RenderView 有两种类型：<strong>光栅化视图</strong>（RasterView），<strong>计算视图</strong>（ComputeView）。</p><h3 id="光栅化视图-rasterview" tabindex="-1">光栅化视图（RasterView） <a class="header-anchor" href="#光栅化视图-rasterview" aria-label="Permalink to &quot;光栅化视图（RasterView）&quot;">​</a></h3><p><strong>光栅化视图</strong> 会被光栅化。有两种子类型：渲染目标（RenderTarget），深度模板（DepthStencil）。</p><img src="'+r+'" width="560"><ul><li><p>slotName 为 shader pixel 分量的名字。（比如color、normal等）</p></li><li><p>accessType 为绑定类型，可以是 Read、ReadWrite、Write。作为输入（Input）时，为Read；作为输出（Output）时为Write；同时作为输入与输出（Inout），为ReadWrite。【注意】深度模板（DepthStencil）在做深度测试（DepthTest）时，虽然结果不写入视图，但此时作为输出，绑定类型依然为Write。部分平台开启ARM_shader_framebuffer_fetch_depth_stencil扩展时，DepthStencil绑定类型为ReadWrite。DepthStencil的绑定类型不能为Read。</p></li><li><p>attachmentType为类型，可以是RenderTarget或者DepthStencil。</p></li><li><p>loadOp 是光栅化读取选项，可以是读取（Load）、清除（Clear）、舍弃（Discard）。</p></li><li><p>storeOp 是光栅化存储选项，可以是写入（Store）、舍弃（Discard）。</p></li><li><p>clearFlags 是清除标志位，如果类型是 RenderTarget，标志位必须是Color。如果类型是 DepthStencil，为 Depth、Stencil、Depth | Stencil三者其一。</p></li><li><p>clearColor 为清除颜色，如果类型是 RenderTarget，为 RGBA（Float4）。如果类型为 DepthStencil，为 RG，此时 R 通道存储 Depth（Float）。G 通道存储 Stencil（Uint8）。</p></li></ul><h3 id="计算视图-computeview" tabindex="-1">计算视图（ComputeView） <a class="header-anchor" href="#计算视图-computeview" aria-label="Permalink to &quot;计算视图（ComputeView）&quot;">​</a></h3><p><strong>计算视图</strong>不会被光栅化。常用于采样（Sample）、乱序读写（Unordered Access）。</p><img src="'+k+'" width="520"><ul><li><p>name 为 Shader 描述符（Descriptor）的名字。</p></li><li><p>accessType 为读写类型。可以是 Read、ReadWrite、Write。</p></li><li><p>clearFlags 为资源的清除类型，一般为 None 或者 Color。</p></li><li><p>clearColor 为资源的清除颜色，为 Float4 或者 Int4。取决于 clearValueType。</p></li><li><p>clearValueType 为资源清除颜色的类型，为 Float 或者 Int。</p></li></ul><p>如果资源标注了清除颜色，那么在执行 <strong>计算通道</strong>（ComputePass）前，会以 clearColor 清除资源内容。光栅类型的通道（Raster）不清除 <strong>计算视图</strong> 内容。</p><h2 id="渲染视图设置" tabindex="-1">渲染视图设置 <a class="header-anchor" href="#渲染视图设置" aria-label="Permalink to &quot;渲染视图设置&quot;">​</a></h2><p><strong>光栅化通道</strong>：</p><img src="'+o+'" width="760"><p><strong>计算通道</strong>：</p><img src="'+d+'" width="760"><h2 id="渲染队列-renderqueue" tabindex="-1">渲染队列（RenderQueue） <a class="header-anchor" href="#渲染队列-renderqueue" aria-label="Permalink to &quot;渲染队列（RenderQueue）&quot;">​</a></h2><p><strong>渲染队列</strong> 是 <strong>渲染通道</strong>（Render Pass）的子节点，有严格的（渲染）先后顺序。只有一个 <strong>渲染队列</strong> 的内容完全绘制后，才会绘制下一个 <strong>渲染队列</strong> 的内容。</p><p><strong>渲染队列</strong> 有两种类型：<strong>光栅化队列</strong>、<strong>计算队列</strong>。分别在 <strong>光栅化通道</strong>、<strong>计算通道</strong> 添加。</p><h3 id="光栅化队列-rasterqueue" tabindex="-1">光栅化队列（RasterQueue） <a class="header-anchor" href="#光栅化队列-rasterqueue" aria-label="Permalink to &quot;光栅化队列（RasterQueue）&quot;">​</a></h3><p><strong>光栅化队列</strong> 执行光栅化任务，一般为绘制 <strong>场景</strong>、绘制全屏四边形等。<strong>光栅化队列</strong> 内部为乱序绘制。</p><img src="'+E+'" width="760"><img src="'+g+'" width="760"><ul><li><p>hint 为队列提示，有 None、Opaque、Cutout、Transparent 四种选项。hint 不会影响执行，只用于性能检测。比如在移动平台上，我们往往希望先绘制 Opaque 队列（关闭 AlphaTest），再绘制 Cutout 队列（开启AlphaTest）。如果在 Opaque 队列的绘制内容中，不小心混入了开启 AlphaTest 的物件，会降低图形性能。因此我们会通过队列提示，检查用户的提交是否符合预期。</p></li><li><p>name 为调试（debug）时显示的名字。为空时，系统会赋予默认名字。</p></li></ul><h3 id="计算队列-computequeue" tabindex="-1">计算队列（ComputeQueue） <a class="header-anchor" href="#计算队列-computequeue" aria-label="Permalink to &quot;计算队列（ComputeQueue）&quot;">​</a></h3><p><strong>计算队列</strong> 只包含 <strong>分发</strong>（Dispatch），顺序执行。</p><img src="'+c+'" width="520"><img src="'+y+'" width="760"><p><strong>计算通道</strong> 没有队列提示。</p><h2 id="渲染内容-rendercontent" tabindex="-1">渲染内容（RenderContent） <a class="header-anchor" href="#渲染内容-rendercontent" aria-label="Permalink to &quot;渲染内容（RenderContent）&quot;">​</a></h2><p><strong>渲染内容</strong> 通过 <strong>渲染队列</strong> 排序、由多种元素组成。</p><h3 id="场景-scene" tabindex="-1">场景（Scene） <a class="header-anchor" href="#场景-scene" aria-label="Permalink to &quot;场景（Scene）&quot;">​</a></h3><p>需要绘制的2D、3D<strong>场景</strong>。适用于<strong>光栅化队列</strong>。</p><img src="'+F+'" width="760"><p>可通过 camera 添加，也可以直接添加。可以附加一定的光照信息。</p><ul><li>sceneFlags一定程度控制 <strong>场景</strong> 的渲染。比如渲染哪些对象（Opaque、Cutout、Transparent）、是否只渲染阴影投射对象（ShadowCaster）、是否只渲染 UI、光照方式（None、Default、Volumetirc、Clustered、PlanarShadow）、是否渲染 GeometryRenderer、是否渲染 Profiler 等。</li></ul><h3 id="矩形-quad" tabindex="-1">矩形（Quad） <a class="header-anchor" href="#矩形-quad" aria-label="Permalink to &quot;矩形（Quad）&quot;">​</a></h3><p>全屏/局部的<strong>矩形</strong>。常用于后期特效渲染。适用于<strong>光栅化队列</strong>。</p><img src="'+u+'" width="760"><h3 id="分发-dispatch" tabindex="-1">分发（Dispatch） <a class="header-anchor" href="#分发-dispatch" aria-label="Permalink to &quot;分发（Dispatch）&quot;">​</a></h3><p>用于<strong>计算队列</strong>。</p><img src="'+m+'" width="760"><h3 id="动态设置" tabindex="-1">动态设置 <a class="header-anchor" href="#动态设置" aria-label="Permalink to &quot;动态设置&quot;">​</a></h3><p>我们可以动态设置Queue、Pass的一些属性。</p><p>比如viewport、clearRenderTarget等。</p><h2 id="渲染数据设置" tabindex="-1">渲染数据设置 <a class="header-anchor" href="#渲染数据设置" aria-label="Permalink to &quot;渲染数据设置&quot;">​</a></h2><p>在编写渲染算法时，我们往往需要设置一些数据供Shader使用。</p><p><strong>渲染流程图</strong>（RenderGraph）在 <strong>渲染通道</strong>（RenderPass）、<strong>渲染队列</strong>（RenderQueue）提供了设置数据的接口。</p><img src="'+C+'" width="760"><p>用户可以设置常量（Constant）、缓冲（Buffer）、贴图（Texture）等数据。</p><p>这些数据可以是只读的、或者始终处于可读写状态。</p><p>对于有读/写状态变化的资源，我们建议用 <strong>渲染视图</strong>（RenderView）进行跟踪。</p><p>每个 <strong>渲染通道</strong>、<strong>渲染队列</strong> 有各自独立的存储。</p><p>每个节点有不同的数据更新/上传频率。用户填写的常量、Shader描述符（Descriptor）的更新频率需要与节点的更新频率一致。</p><ul><li><p><strong>渲染通道</strong>：每 <strong>渲染通道</strong> 上传一次（PerPass）。</p></li><li><p><strong>渲染队列</strong>：每 <strong>渲染阶段</strong> 上传一次（PerPhase）。</p></li></ul><img src="'+D+'" width="760"><h2 id="功能开启" tabindex="-1">功能开启 <a class="header-anchor" href="#功能开启" aria-label="Permalink to &quot;功能开启&quot;">​</a></h2><p>勾选 <strong>自定义渲染管线</strong>。</p><img src="'+A+'" width="760"><p>通过填写 <strong>自定义管线</strong> 的名字，选择注册好的 <strong>自定义渲染管线</strong>。</p><ul><li>目前支持 <strong>Custom</strong>, <strong>Forward</strong>, <strong>Deferred</strong> 三种 (其中 Custom 是基于 Forward 基础上添加的 Bloom 后效示例)。</li></ul><img src="'+P+`" width="760"><h2 id="编写自定义渲染管线" tabindex="-1">编写自定义渲染管线 <a class="header-anchor" href="#编写自定义渲染管线" aria-label="Permalink to &quot;编写自定义渲染管线&quot;">​</a></h2><p>新建 TypeScript 文件，定义名为 <code>TestCustomPipeline</code> 类，让该类实现 <code>rendering.PipelineBuilder</code> 接口，通过 <code>rendering.setCustomPipeline</code> 方法把该 pipeline 注册到系统中，如下代码所示。</p><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { _decorator, rendering, renderer, game, Game } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;cc&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { AntiAliasing, buildForwardPass, buildBloomPasses,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    buildFxaaPass, buildPostprocessPass, buildUIPass, isUICamera, decideProfilerCamera } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;./PassUtils&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> TestCustomPipeline</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> implements</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> rendering</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">PipelineBuilder</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    setup</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">cameras</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> renderer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">scene</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Camera</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[], </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">pipeline</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> rendering</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Pipeline</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> void</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        decideProfilerCamera</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(cameras);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> cameras.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> camera</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> cameras[i];</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (camera.scene </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">                continue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> isGameView</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> camera.cameraUsage </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> renderer.scene.CameraUsage.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">GAME</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">                ||</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> camera.cameraUsage </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> renderer.scene.CameraUsage.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">GAME_VIEW</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">isGameView) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">                // forward pass</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">                buildForwardPass</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(camera, pipeline, isGameView);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">                continue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            }</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">            // TODO: The actual project is not so simple to determine whether the ui camera, here is just as a demo demonstration.</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">isUICamera</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(camera)) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">                // forward pass</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">                const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> forwardInfo</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> buildForwardPass</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(camera, pipeline, isGameView);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">                // fxaa pass</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">                const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> fxaaInfo</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> buildFxaaPass</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(camera, pipeline, forwardInfo.rtName);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">                // bloom passes</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">                const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> bloomInfo</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> buildBloomPasses</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(camera, pipeline, fxaaInfo.rtName);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">                // Present Pass</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">                buildPostprocessPass</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(camera, pipeline, bloomInfo.rtName, AntiAliasing.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">NONE</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">                continue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            }</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">            // render ui</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">            buildUIPass</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(camera, pipeline);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">game.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">on</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Game.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">EVENT_RENDERER_INITED</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    rendering.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setCustomPipeline</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Test&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">new</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> TestCustomPipeline);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre></div><p>可以看到上述代码引用了 PassUtils 脚本文件,该文件通过简单封装常用 <code>RenderPass</code> 的相关逻辑，方便用户直接使用（PassUtils可以在这 <a href="./code/PassUtils.ts">下载</a>）。</p><p>PassUtils有不少函数，我们抽取 <code>buildPostprocessPass</code> 的部分逻辑来介绍：</p><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> buildPostprocessPass</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">camera</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">    ppl</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">    inputTex</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> string</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">    antiAliasing</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> AntiAliasing</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> AntiAliasing.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">NONE</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // ...</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> postprocessPassRTName</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> \`postprocessPassRTName\${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">cameraID</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}\`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> postprocessPassDS</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> \`postprocessPassDS\${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">cameraID</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}\`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ppl.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">containsResource</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(postprocessPassRTName)) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 注册 color texture 资源，因为当前 pass 是要上屏，所以传递 camera.window 作为上屏信息。如果是离屏的则需要调用 ppl.addRenderTarget 函数即可</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        ppl.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">addRenderTexture</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(postprocessPassRTName, Format.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">BGRA8</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, width, height, camera.window);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 注册 depthStencil texture 资源</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        ppl.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">addDepthStencil</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(postprocessPassDS, Format.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">DEPTH_STENCIL</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, width, height, ResourceResidency.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">MANAGED</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 下面两行会更新 color texture 与 depthStencil texture 的注册信息(主要为尺寸大小)，同样如果离屏的则调用 &#39;ppl.updateRenderTarget&#39; 函数</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ppl.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">updateRenderWindow</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(postprocessPassRTName, camera.window);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ppl.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">updateDepthStencil</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(postprocessPassDS, width, height);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 注册一个 RasterPass，它的 layoutName 为 post-process</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> postprocessPass</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ppl.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">addRasterPass</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(width, height, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;post-process&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    postprocessPass.name </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> \`CameraPostprocessPass\${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">cameraID</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}\`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 设置当前 rasterPass 的 viewport</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    postprocessPass.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setViewport</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Viewport</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(area.x, area.y, area.width, area.height));</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 判断系统中是否有输入纹理的同名信息，并把该输入纹理注入到 outputResultMap的sampler 中</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (ppl.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">containsResource</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(inputTex)) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> computeView</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ComputeView</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        computeView.name </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;outputResultMap&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        postprocessPass.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">addComputeView</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(inputTex, computeView);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 设置 postprocessPass 的 clear color 信息</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> postClearColor</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Color</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, camera.clearColor.w);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (camera.clearFlag </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ClearFlagBit.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">COLOR</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        postClearColor.x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> camera.clearColor.x;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        postClearColor.y </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> camera.clearColor.y;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        postClearColor.z </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> camera.clearColor.z;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 注册 color texture 相关的 pass view</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> postprocessPassView</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> RasterView</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;_&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        AccessType.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">WRITE</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, AttachmentType.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">RENDER_TARGET</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        getLoadOpOfClearFlag</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(camera.clearFlag, AttachmentType.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">RENDER_TARGET</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">),</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        StoreOp.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">STORE</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        camera.clearFlag,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        postClearColor);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 注册 depth stencil texture 相关的 pass view</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> postprocessPassDSView</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> RasterView</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;_&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        AccessType.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">WRITE</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, AttachmentType.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">DEPTH_STENCIL</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        getLoadOpOfClearFlag</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(camera.clearFlag, AttachmentType.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">DEPTH_STENCIL</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">),</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        StoreOp.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">STORE</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        camera.clearFlag,</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Color</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(camera.clearDepth, camera.clearStencil, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">));</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 把 color texture 资源与相关的pass view产生关联(即 renderpass 的 color texture 输出口)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    postprocessPass.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">addRasterView</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(postprocessPassRTName, postprocessPassView);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 把 depth stencil texture 资源与相关的 pass view 产生关联</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    postprocessPass.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">addRasterView</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(postprocessPassDS, postprocessPassDSView);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 添加具体的渲染队列，拿到 postprocess material 去画一个与屏幕等尺寸的四边形</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    postprocessPass.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">addQueue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(QueueHint.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">NONE</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">addFullscreenQuad</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        postInfo.postMaterial, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, SceneFlags.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">NONE</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    );</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // ...</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (profilerCamera </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> camera) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 开启 profiler 渲染</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        postprocessPass.showStatistics </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 把 color texture 与 depth stencil texture 的资源返回，可以用于后续其它 render pass 的数据源</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { rtName: postprocessPassRTName, dsName: postprocessPassDS };</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>首先我们需要知道 <code>RasterPass</code> 如何配置 <code>layoutName</code> （即上述代码中的 post-process 字符串）。打开 <code>post-process.effect</code> 文件后，可以看到内部定义的 <code>pass</code> 名称就是 <code>post-process</code> ，所以 effect 文件中的 pass name 就是作为 RasterPass 的 <code>layoutName</code>。如果 effect 没有定义 pass name，那么 <code>RasterPass</code> 的 <code>layoutName</code> 就得赋值为 <code>default</code> （forward/gbuffer 相关的 RasterPass 都是通过 default 配置）。所以要配置自己的后处理方案，就需要为自己编写的 effect 文件正确配置 pass name。</p><img src="`+B+'" width="760"><p>另外我们还需要把上一个 pass 的输出纹理作为当前 pass 的输入信息，上面说到需要通过 <code>ComputeView</code> 实现，而这里 <code>ComputeView</code> 的 name 设置为了 <code>outputResultMap</code>，那么该怎么正确配置这个名称？继续对 <code>post-process.effect</code> 文件分析，可以看到下面的代码，<code>ComputeView</code> 的 name 与 <code>post-process-fs</code> 的片元着色器的纹理输入名称一致。</p><img src="'+R+'" width="760"><p>同时我们需要通过下述代码行对 <code>outputResultMap</code> 名称进行声明，表明该输入纹理的使用频率为 Pass level。</p><div class="language-glsl vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">glsl</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#pragma</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> rate</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> outputResultMap</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> pass</span></span></code></pre></div><p>定义完 <code>TestCustomPipeline</code> 后需要通过其它逻辑代码（如：组件等）引入该文件，以便激活 <code>Game.EVENT_RENDERER_INITED</code> 事件监听，之后改变 <strong>项目设置</strong> -&gt; <strong>宏配置</strong> -&gt; <strong>CUSTOM_PIPELINE_NAME</strong> 为 <code>Test</code>:</p><img src="'+w+'" width="760"><p>运行后的效果如下所示,它包含了 fxaa 与 bloom 的后效：</p><img src="'+_+'" width="760"><p>这就是定义一个 <code>RenderPass</code> 的流程，PassUtils 还定义了其它 Pass 可以提供用户参考，包括 <code>BloomPasses</code>，<code>FxaaPass</code> 等。这些 <code>RenderPass</code> 提供了调节参数可对输出效果进行调整（如Bloom的曝光强度，迭代次数等），用户可查看相关的代码进行尝试。</p>',121),q=[b];function T(x,S,N,V,v,I){return a(),i("div",null,q)}const U=s(f,[["render",T]]);export{O as __pageData,U as default};
