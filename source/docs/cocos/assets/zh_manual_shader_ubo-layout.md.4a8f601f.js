import{_ as s,v as a,b as n,R as l}from"./chunks/framework.5ffcbaff.js";const D=JSON.parse('{"title":"UBO 内存布局策略","description":"","frontmatter":{},"headers":[],"relativePath":"zh/manual/shader/ubo-layout.md","filePath":"zh/manual/shader/ubo-layout.md"}'),o={name:"zh/manual/shader/ubo-layout.md"},e=l(`<h1 id="ubo-内存布局策略" tabindex="-1">UBO 内存布局策略 <a class="header-anchor" href="#ubo-内存布局策略" aria-label="Permalink to &quot;UBO 内存布局策略&quot;">​</a></h1><p>Cocos Shader 规定，所有非 sampler 类型的 uniform 都应以 UBO（Uniform Buffer Object/Uniform Block）形式声明。</p><p>以内置着色器 <code>builtin-standard.effect</code> 为例，其 uniform block 声明如下：</p><div class="language-glsl"><button title="Copy Code" class="copy"></button><span class="lang">glsl</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">uniform</span><span style="color:#A6ACCD;"> Constants </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    vec4 tilingOffset</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">    vec4 albedo</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">    vec4 albedoScaleAndCutoff</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">    vec4 pbrParams</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">    vec4 miscParams</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">    vec4 emissive</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">    vec4 emissiveScaleParam</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">};</span></span></code></pre></div><p>并且所有的 UBO 应当遵守以下规则：</p><ol><li>不应出现 vec3 成员；</li><li>对数组类型成员，每个元素 size 不能小于 vec4；</li><li>不允许任何会引入 padding 的成员声明顺序。</li></ol><p>Cocos Shader 在编译时会对上述规则进行检查，以便在导入错误（implicit padding 相关）时及时提醒修改。</p><p>这可能听起来有些过分严格，但背后有非常务实的考量：<br> 首先，UBO 是渲染管线内要做到高效数据复用的唯一基本单位，离散声明已不是一个选项；<br> 其次，WebGL2 的 UBO 只支持 std140 布局，它遵守一套比较原始的 padding 规则[^1]：</p><ul><li><p>所有 vec3 成员都会补齐至 vec4：</p><div class="language-glsl"><button title="Copy Code" class="copy"></button><span class="lang">glsl</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">uniform</span><span style="color:#A6ACCD;"> ControversialType </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  vec3 v3_1</span><span style="color:#89DDFF;">;</span><span style="color:#676E95;font-style:italic;"> // offset 0, length 16 [IMPLICIT PADDING!]</span></span>
<span class="line"><span style="color:#89DDFF;">};</span><span style="color:#676E95;font-style:italic;"> // total of 16 bytes</span></span></code></pre></div></li><li><p>任意长度小于 vec4 类型的数组和结构体，都会将元素补齐至 vec4：</p><div class="language-glsl"><button title="Copy Code" class="copy"></button><span class="lang">glsl</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">uniform</span><span style="color:#A6ACCD;"> ProblematicArrays </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#C792EA;">float</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">f4_1</span><span style="color:#89DDFF;">[</span><span style="color:#F78C6C;">4</span><span style="color:#89DDFF;">];</span><span style="color:#676E95;font-style:italic;"> // offset 0, stride 16, length 64 [IMPLICIT PADDING!]</span></span>
<span class="line"><span style="color:#89DDFF;">};</span><span style="color:#676E95;font-style:italic;"> // total of 64 bytes</span></span></code></pre></div></li><li><p>所有成员在 UBO 内的实际偏移都会按自身所占字节数对齐[^2]：</p><div class="language-glsl"><button title="Copy Code" class="copy"></button><span class="lang">glsl</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">uniform</span><span style="color:#A6ACCD;"> IncorrectUBOOrder </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#C792EA;">float</span><span style="color:#F07178;"> f1_1</span><span style="color:#89DDFF;">;</span><span style="color:#676E95;font-style:italic;"> // offset 0, length 4 (aligned to 4 bytes)</span></span>
<span class="line"><span style="color:#F07178;">  vec2 v2</span><span style="color:#89DDFF;">;</span><span style="color:#676E95;font-style:italic;"> // offset 8, length 8 (aligned to 8 bytes) [IMPLICIT PADDING!]</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#C792EA;">float</span><span style="color:#F07178;"> f1_2</span><span style="color:#89DDFF;">;</span><span style="color:#676E95;font-style:italic;"> // offset 16, length 4 (aligned to 4 bytes)</span></span>
<span class="line"><span style="color:#89DDFF;">};</span><span style="color:#676E95;font-style:italic;"> // total of 32 bytes</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C792EA;">uniform</span><span style="color:#A6ACCD;"> CorrectUBOOrder </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#C792EA;">float</span><span style="color:#F07178;"> f1_1</span><span style="color:#89DDFF;">;</span><span style="color:#676E95;font-style:italic;"> // offset 0, length 4 (aligned to 4 bytes)</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#C792EA;">float</span><span style="color:#F07178;"> f1_2</span><span style="color:#89DDFF;">;</span><span style="color:#676E95;font-style:italic;"> // offset 4, length 4 (aligned to 4 bytes)</span></span>
<span class="line"><span style="color:#F07178;">  vec2 v2</span><span style="color:#89DDFF;">;</span><span style="color:#676E95;font-style:italic;"> // offset 8, length 8 (aligned to 8 bytes)</span></span>
<span class="line"><span style="color:#89DDFF;">};</span><span style="color:#676E95;font-style:italic;"> // total of 16 bytes</span></span></code></pre></div></li></ul><p>这意味着大量的空间浪费，且某些设备的驱动实现也并不完全符合此标准[^3]，因此目前 Cocos Shader 选择限制这部分功能的使用，以帮助排除一部分非常隐晦的运行时问题。</p><blockquote><p><strong>再次提醒：uniform 的类型与 inspector 的显示和运行时参数赋值时的程序接口可以不直接对应，通过 <a href="./pass-parameter-list.html#Properties">property target</a> 机制，可以独立编辑任意 uniform 的具体分量。</strong></p></blockquote><p>[^1]: <a href="http://www.opengl.org/registry/doc/glspec45.core.pdf#page=159" target="_blank" rel="noreferrer">OpenGL 4.5, Section 7.6.2.2, page 137</a></p><p>[^2]: 注意在示例代码中，UBO IncorrectUBOOrder 的总长度为 32 字节，实际上这个数据到今天也依然是平台相关的，看起来是由于 GLSL 标准的疏忽，更多相关讨论可以参考 <a href="https://bugs.chromium.org/p/chromium/issues/detail?id=988988" target="_blank" rel="noreferrer">这里</a>。</p><p>[^3]: <strong>Interface Block - OpenGL Wiki</strong>：<a href="https://www.khronos.org/opengl/wiki/Interface_Block_(GLSL)#Memory_layout" target="_blank" rel="noreferrer">https://www.khronos.org/opengl/wiki/Interface_Block_(GLSL)#Memory_layout</a></p>`,14),p=[e];function t(c,r,i,y,f,F){return a(),n("div",null,p)}const g=s(o,[["render",t]]);export{D as __pageData,g as default};
