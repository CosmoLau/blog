import{_ as t,v as e,b as l,F as s,L as a,E as o,O as p,R as r,M as c}from"./chunks/framework.5ffcbaff.js";const M=JSON.parse('{"title":"自定义表面着色器","description":"","frontmatter":{},"headers":[],"relativePath":"zh/manual/shader/surface-shader/customize-surface-shader.md","filePath":"zh/manual/shader/surface-shader/customize-surface-shader.md"}'),i={name:"zh/manual/shader/surface-shader/customize-surface-shader.md"},d=r(`<h1 id="自定义表面着色器" tabindex="-1">自定义表面着色器 <a class="header-anchor" href="#自定义表面着色器" aria-label="Permalink to &quot;自定义表面着色器&quot;">​</a></h1><p>虽然 Surface Shader 提供了大多数场景材质都能适配的光照模型，但其功能还是较为固定的。</p><p>有时候，<strong>用户需要使用完全定制化的光照计算和色彩计算</strong>，比如说：一些特殊的、风格化的材质，需要轮廓光、额外的补光、非真实的环境照明等等。</p><p>针对这类极为特殊的情况，Surface Shader 也提供了自定义能力。</p><p>但需要注意的是，由于干预了表面材质数据和光照计算过程，渲染效果可能会出现意料之外的效果。</p><h2 id="_1、自定义-vs-输出与-fs-输入" tabindex="-1">1、自定义 VS 输出与 FS 输入 <a class="header-anchor" href="#_1、自定义-vs-输出与-fs-输入" aria-label="Permalink to &quot;1、自定义 VS 输出与 FS 输入&quot;">​</a></h2><p>我们可以在 VS 阶段新定义一个传递变量之后，在某个 Surface 函数中计算并输出该变量值。</p><p>在 FS 阶段定义一个同名变量之后在某个 Surface 函数中获取并使用该变量值。</p><p>详情请参考 <a href="./fs-input.html">Fragment Shader 的输入参数</a>：<strong>自定义传递值</strong>。</p><h2 id="_2、自定义材质信息" tabindex="-1">2、自定义材质信息 <a class="header-anchor" href="#_2、自定义材质信息" aria-label="Permalink to &quot;2、自定义材质信息&quot;">​</a></h2><p>在 VS 函数块中添加如下代码：</p><div class="language-glsl"><button title="Copy Code" class="copy"></button><span class="lang">glsl</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#676E95;font-style:italic;">//PBR 光照模型</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">#include</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&lt;</span><span style="color:#C3E88D;">surfaces/data-structures/standard</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// toon 光照模型</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">//#include &lt;surfaces/data-structures/toon&gt; </span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">#define</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">CC_SURFACES_FRAGMENT_MODIFY_SHARED_DATA</span></span>
<span class="line"><span style="color:#C792EA;">void</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">SurfacesFragmentModifySharedData</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">inout SurfacesMaterialData </span><span style="color:#A6ACCD;font-style:italic;">surfaceData</span><span style="color:#89DDFF;">)</span></span>
<span class="line"><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// set user-defined data to surfaceData</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span></code></pre></div><p>函数开头的 <code>#include</code> 用于决定使用的<strong>材质数据结构名称</strong>，根据不同的 include 文件, 会采用不同的 <code>SurfacesMaterialData</code> 结构体。</p><p>具体内容，可以查看 <strong>internal/chunks/surfaces/data-structures/</strong> 目录下的 <strong>standard.chunk</strong> 和 <strong>toon.chunk</strong></p><p>当定义了 <code>CC_SURFACES_FRAGMENT_MODIFY_SHARED_DATA</code> 宏后，Shader编译器会选择你自己写的 <code>SurfacesFragmentModifySharedData</code> 来替换默认的函数。</p><p>此函数会在 vs 阶段被调用，具体可以查看 <strong>internal/chunks/shading-entries/main-functions/</strong> 目录下的： <strong>render-to-scene/vs.chunk</strong> 和 <strong>render-to-shadowmap/vs.chunk</strong> 文件。</p><p>在这个函数中，我们可以直接修改 surfaceData 里的属性，为光照阶段做准备。</p><h2 id="自定义光照计算结果" tabindex="-1">自定义光照计算结果 <a class="header-anchor" href="#自定义光照计算结果" aria-label="Permalink to &quot;自定义光照计算结果&quot;">​</a></h2><p>有了上面自定义的 SurfacesMaterialData，我们还需要配合光照阶段，才能实现我们想要的计算效果。</p><p>在 FS 中，添加下面的代码：</p><div class="language-glsl"><button title="Copy Code" class="copy"></button><span class="lang">glsl</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;font-style:italic;">#include</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&lt;</span><span style="color:#C3E88D;">lighting-models/includes/common</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">#define</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">CC_SURFACES_LIGHTING_MODIFY_FINAL_RESULT</span></span>
<span class="line"><span style="color:#C792EA;">void</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">SurfacesLightingModifyFinalResult</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">inout LightingResult </span><span style="color:#A6ACCD;font-style:italic;">result</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> in LightingIntermediateData </span><span style="color:#A6ACCD;font-style:italic;">lightingData</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> in SurfacesMaterialData </span><span style="color:#A6ACCD;font-style:italic;">surfaceData</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> in LightingMiscData </span><span style="color:#A6ACCD;font-style:italic;">miscData</span><span style="color:#89DDFF;">)</span></span>
<span class="line"><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// use surfaceData and lightingData for customizing lighting result</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span></code></pre></div><p>这个函数会在 fs.chunk 中被调用。</p><p>可以看到函数有四个参数：</p><ul><li>LightingIntermediateData：计算光照时需要的信息，如法线、视线方向、视距等等</li><li>SurfacesMaterialData：颜色、世界空间法线、PBR参数等信息</li><li>LightingMiscData：光源类型、位置、方向、颜色、强度等</li><li>LightingResult：用于返回光照结果，如 diffuse, specular, shadow,ao 等等。</li></ul><p>在这个函数中，可以利用光照和材质参数，计算出光照结果，并放入 result 中。</p><p>对于局部光源（点光、聚光灯等）而言，此函数会逐光源执行。也就是说，如果物体受 6 个光源影响，这个函数会被调用 6 次。</p>`,26),u=s("p",null,"比如，如果想要在函数中使用 PBR 光照模型内置的光照函数，可以包含 lighting-models/includes/standard 头文件。",-1),h=s("p",null,"在这个头文件中，会包含 lighting-models/model-functions/standard 头文件。",-1),D=s("p",null,"PBR光照相关的内置函数都在这里，直接调用即可。",-1),f=s("h2",{id:"更多自定义",tabindex:"-1"},[a("更多自定义 "),s("a",{class:"header-anchor",href:"#更多自定义","aria-label":'Permalink to "更多自定义"'},"​")],-1),y=s("p",null,"如果上面的自定义机制还不能满足需求，建议参考 chunks/shading-entries 构建自己的 main 函数，以控制整个着色流程和计算细节。",-1);function F(g,A,C,m,_,S){const n=c("font");return e(),l("div",null,[d,s("p",null,[a("如果希望 "),o(n,{color:"#ff0000"},{default:p(()=>[a("在重载函数内可以直接调用现成的内置光照模块函数")]),_:1}),a("，可以将 lighting-models/includes/common 改为对应光照模型使用的头文件。")]),u,h,D,f,y])}const R=t(i,[["render",F]]);export{M as __pageData,R as default};
