import{_ as t,c as s,o as a,a4 as i}from"./chunks/framework.uQk9_EO2.js";const e="/docs/cocos/assets/macro-remapping.DhX0mJgL.png",g=JSON.parse('{"title":"宏定义与重映射","description":"","frontmatter":{},"headers":[],"relativePath":"zh/shader/surface-shader/macro-remapping.md","filePath":"zh/shader/surface-shader/macro-remapping.md","lastUpdated":1712305443000}'),l={name:"zh/shader/surface-shader/macro-remapping.md"},d=i('<h1 id="宏定义与重映射" tabindex="-1">宏定义与重映射 <a class="header-anchor" href="#宏定义与重映射" aria-label="Permalink to &quot;宏定义与重映射&quot;">​</a></h1><p>Surface Shader 内部计算时会用到一些宏开关，这些宏以 <code>CC_SURFACES_</code> 开头。</p><blockquote><p>注意：以 <code>CC_SURFACES_</code> 开头的宏不会出现在材质面板上。</p></blockquote><p>以下是完整的宏列表：</p><table><thead><tr><th style="text-align:left;">宏名</th><th>类型</th><th>含义</th></tr></thead><tbody><tr><td style="text-align:left;">CC_SURFACES_USE_VERTEX_COLOR</td><td>BOOL</td><td>是否使用顶点色</td></tr><tr><td style="text-align:left;">CC_SURFACES_USE_SECOND_UV</td><td>BOOL</td><td>是否使用2uv</td></tr><tr><td style="text-align:left;">CC_SURFACES_USE_TWO_SIDED</td><td>BOOL</td><td>是否使用双面法线，用于双面光照</td></tr><tr><td style="text-align:left;">CC_SURFACES_USE_TANGENT_SPACE</td><td>BOOL</td><td>是否使用切空间（使用法线图或各向异性时必须开启）</td></tr><tr><td style="text-align:left;">CC_SURFACES_TRANSFER_LOCAL_POS</td><td>BOOL</td><td>是否在 FS 中访问模型空间坐标</td></tr><tr><td style="text-align:left;">CC_SURFACES_LIGHTING_ANISOTROPIC</td><td>BOOL</td><td>是否开启各向异性材质</td></tr><tr><td style="text-align:left;">CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT</td><td>UINT</td><td>各向异性环境光卷积采样数，为 0 表示关闭卷积计算，仅当各向异性开启时有效</td></tr><tr><td style="text-align:left;">CC_SURFACES_LIGHTING_USE_FRESNEL</td><td>BOOL</td><td>是否通过相对折射率 ior 计算菲涅耳系数</td></tr><tr><td style="text-align:left;">CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE</td><td>BOOL</td><td>是否开启背面穿透漫射光（如头发、叶片、耳朵等）</td></tr><tr><td style="text-align:left;">CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR</td><td>BOOL</td><td>是否开启背面穿透高光（如水面、玻璃折射等）</td></tr><tr><td style="text-align:left;">CC_SURFACES_LIGHTING_TRT</td><td>BOOL</td><td>是否开启透射后内部镜面反射出的光线（如头发材质等）</td></tr><tr><td style="text-align:left;">CC_SURFACES_LIGHTING_TT</td><td>BOOL</td><td>是否开启透射后内部漫反射出的光线（用于头发材质）</td></tr><tr><td style="text-align:left;">CC_SURFACES_USE_REFLECTION_DENOISE</td><td>BOOL</td><td>是否开启环境反射除噪，仅 legacy 兼容模式下生效</td></tr><tr><td style="text-align:left;">CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING</td><td>BOOL</td><td>是否开启 legacy 兼容光照模式，可使渲染效果和 legacy/standard.effect 完全一致，便于升级</td></tr></tbody></table><blockquote><p><strong>注意</strong>： 如果未定义这些宏，系统内部会自动定义为默认值 0；</p></blockquote><p>搜索 <code>CCProgram macro-remapping</code> 一段，可以看到内容有如下三部分组成：</p><p><img src="'+e+`" alt="macro-remapping"></p><h2 id="仅供面板显示的宏" tabindex="-1">仅供面板显示的宏 <a class="header-anchor" href="#仅供面板显示的宏" aria-label="Permalink to &quot;仅供面板显示的宏&quot;">​</a></h2><div class="language-glsl vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">glsl</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// ui displayed macros not used in this effect file</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#pragma</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> define-meta</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> HAS_SECOND_UV</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#pragma</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> define-meta</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> USE_TWOSIDE</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#pragma</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> define-meta</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> USE_REFLECTION_DENOISE</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#pragma</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> define-meta</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> USE_COMPATIBLE_LIGHTING</span></span></code></pre></div><p>默认情况下，以 <code>CC_</code> 开头的宏不会显示在材质面板上。 当我们想让某一个宏开关显示在材质面板上时，可以像下面这样操作：</p><p>1、使用 <code>#pragma define-meta</code> 定义一个面板宏，我们以 <code>HAS_SECOND_UV</code> 为例：</p><div class="language-glsl vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">glsl</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#pragma</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> define-meta</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> HAS_SECOND_UV</span></span></code></pre></div><p>2、将 <code>CC_SURFACES_</code> 开头的宏重定向到这个宏，示例如下：</p><div class="language-glsl vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">glsl</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#define</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> CC_SURFACES_USE_SECOND_UV</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> HAS_SECOND_UV</span></span></code></pre></div><p>这样，在这个 Shader 对应的材质面板上，你就可以通过控制 <code>HAS_SECOND_UV</code> 来影响 <code>CC_SURFACES_USE_SECOND_UV</code> 宏的值。</p><h2 id="在-surface-函数中使用过的宏" tabindex="-1">在 Surface 函数中使用过的宏 <a class="header-anchor" href="#在-surface-函数中使用过的宏" aria-label="Permalink to &quot;在 Surface 函数中使用过的宏&quot;">​</a></h2><p>如果有宏在 Shader 代码中被使用，且不是以 <code>CC_</code> 开头的，会自动显示在材质面板上。 比如：</p><div class="language-glsl vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">glsl</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// ui displayed macros used in this effect file</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#define</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> CC_SURFACES_USE_VERTEX_COLOR</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> USE_VERTEX_COLOR</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#if</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> IS_ANISOTROPY</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ||</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> USE_NORMAL_MAP</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  #define</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> CC_SURFACES_USE_TANGENT_SPACE</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#endif</span></span></code></pre></div><p>这种情况下，IS_ANISOTROPY 和 USE_NORMAL_MAP 会显示在材质面板上，并可以通过材质面板进行开关。</p><h2 id="内部功能性的宏" tabindex="-1">内部功能性的宏 <a class="header-anchor" href="#内部功能性的宏" aria-label="Permalink to &quot;内部功能性的宏&quot;">​</a></h2><p>对于某一些宏，我们不想要面板控制它，直接定义它的值即可，例如：</p><div class="language-glsl vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">glsl</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// functionality for each effect</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#define</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 31</span></span></code></pre></div><h2 id="隐藏宏" tabindex="-1">隐藏宏 <a class="header-anchor" href="#隐藏宏" aria-label="Permalink to &quot;隐藏宏&quot;">​</a></h2><p>如果你的 Shader 中写了一些宏，但是不想出现在材质面板上，可以用 <code>CC_</code> 开头。</p><p>为了和系统内部宏有区别，建议使用 <code>CC_USER_</code> 开头。</p><p>更多宏定义相关内容，可以查看 <a href="./../macros">预处理宏定义</a>。</p>`,27),n=[d];function p(h,r,c,_,o,C){return a(),s("div",null,n)}const S=t(l,[["render",p]]);export{g as __pageData,S as default};
