import{_ as e,v as d,b as i,R as r}from"./chunks/framework.5ffcbaff.js";const m=JSON.parse('{"title":"自定义渲染管线（Deprecated）","description":"","frontmatter":{},"headers":[],"relativePath":"zh/manual/render-pipeline/user-pipeline.md","filePath":"zh/manual/render-pipeline/user-pipeline.md"}'),l={name:"zh/manual/render-pipeline/user-pipeline.md"},n=r('<h1 id="自定义渲染管线-deprecated" tabindex="-1">自定义渲染管线（Deprecated） <a class="header-anchor" href="#自定义渲染管线-deprecated" aria-label="Permalink to &quot;自定义渲染管线（Deprecated）&quot;">​</a></h1><p>要创建一个自定义的渲染管线，首先要在 <strong>资源管理器</strong> 面板中新建一个 RenderPipeline 资源，再创建一个 RenderPipeline 脚本，然后在 Pipeline 资源中选择对应的 RenderPipeline 脚本，即可编辑对应的属性。</p><p>RenderFlow 和 RenderStage 使用同样的方式进行创建和编辑。在创建出来的 Pipeline 脚本中，可以像其它用户脚本一样添加属性并使其可以在 <strong>属性检查器</strong> 面板中编辑，但需要注意的是不能拖放场景中的实体，因为 RenderPipeline 并不和某个具体的场景绑定。</p><h2 id="renderpipeline-中的属性和方法" tabindex="-1">RenderPipeline 中的属性和方法 <a class="header-anchor" href="#renderpipeline-中的属性和方法" aria-label="Permalink to &quot;RenderPipeline 中的属性和方法&quot;">​</a></h2><ul><li><p><code>flows</code>：RenderPipeline 中包含的 RenderFlow。</p></li><li><p><code>renderTextures</code>：在 RenderPipeline 启动时可创建的 RenderTexture。</p><ul><li><code>name</code>：RenderTexture 的名字，创建后可通过 RenderPipeline 的 <code>getRenderTexture</code> 函数获取。</li><li><code>type</code>：RenderTexture 的类型。</li><li><code>viewType</code>：RenderTexture 对应的 TextureView 类型。</li><li><code>usage</code>：RenderTexture 的绑定类型，用于确定是 <code>color</code> 还是 <code>depth_stencil</code>。</li><li><code>formate</code>：RenderTexture 的通道格式。</li><li><code>width</code>：RenderTexture 的宽度，-1 表示窗口宽度。</li><li><code>height</code>：RenderTexture 高度，-1 表示窗口高度。</li></ul></li><li><p><code>framebuffers</code>：在 RenderPipeline 启动时可创建的 FrameBuffer。</p><ul><li><code>name</code>：FrameBuffer 的名字，创建后可通过 RenderPipeline 的 <code>getFrameBuffer</code> 函数获取。</li><li><code>renderPass</code>：RenderPass。RenderPipeline 中配置的 RenderPass 的 ID。</li><li><code>colorViews</code>：与 ColorAttachment 绑定的 TextureView。指定 RenderPipeline 中配置的 RenderTexture。</li><li><code>depthStencilView</code>：与 DepthStencilAttachment 绑定的 TextureView。指定 RenderPipeline 中配置的 RenderTexture。</li></ul></li><li><p><code>renderPasses</code>：在 RenderPipeline 启动时可创建的 RenderPass。</p><ul><li><code>index</code>：RenderPass 的 ID，可通过 RenderPipeline 的 <code>getRenderPass</code> 函数获取。</li><li><code>colorAttachments</code>：ColorAttachment 描述，绘制 FrameBuffer 时对 ColorAttachment 的操作。</li><li><code>depthStencilAttachment</code>：DepthStencilAttachment 描述，绘制 FrameBuffer 时对 DepthStencilAttachment 的操作。</li></ul></li><li><p><code>getTextureView</code> (name: string)，<code>getRenderTexture</code> (name: string)：用于获取在 renderTextures 配置的 RenderTexture。</p></li><li><p><code>getFrameBuffer</code> (name: string)：用于获取在 framebuffers 配置的 FrameBuffer。</p></li><li><p><code>getRenderPass</code> (stage: number)：用于获取在 renderPasses 配置的 RenderPass。</p></li><li><p><code>initialize</code> (info: IRenderPipelineInfo)：用于通过脚本创建一个 RenderPipeline 时的初始化函数，RenderPipeline 必须初始化后才能使用。</p></li><li><p><code>activate</code> (root: Root)：用于通过资源加载一个 RenderPipeline 时的初始化函数，RenderPipeline 必须初始化后才能使用。</p></li><li><p><code>render</code> (view: RenderView)：渲染场景的逻辑。</p></li><li><p><code>updateUBOs</code> (view: RenderView)：更新全局 UniformBuffer。</p></li><li><p><code>sceneCulling</code> (view: RenderView)：场景剔除，剔除后可渲染物体保存在 <code>_renderObjects</code> 中。</p></li></ul><h2 id="renderflow-中的属性和方法" tabindex="-1">RenderFlow 中的属性和方法 <a class="header-anchor" href="#renderflow-中的属性和方法" aria-label="Permalink to &quot;RenderFlow 中的属性和方法&quot;">​</a></h2><ul><li><code>name</code>：RenderFlow 的名字。</li><li><code>priority</code>：RenderFlow 在 RenderPipeline 中的执行顺序。</li><li><code>type</code>：RenderFlow 的类型。包括以下三种： <ul><li><code>SCENE</code>：用于绘制场景，该类型对于每个 camera 都会执行；</li><li><code>POSTPROCESS</code>：后期处理，该类型对每个 camera 都要单独指定；</li><li><code>UI</code>：用于绘制 UI。</li></ul></li><li><code>stages</code>：RenderFlow 包含的 RenderStage。</li></ul><h2 id="renderstage-中的属性和方法" tabindex="-1">RenderStage 中的属性和方法 <a class="header-anchor" href="#renderstage-中的属性和方法" aria-label="Permalink to &quot;RenderStage 中的属性和方法&quot;">​</a></h2><ul><li><code>name</code>：RenderStage 的名字。</li><li><code>priority</code>：RenderStage 在 RenderFlow 中的执行顺序。</li><li><code>frameBuffer</code>：RenderStage 要绘制到的 FrameBuffer，应设置为 RenderPipeline 中配置的 FrameBuffer，或设置为 <code>window</code>，表示使用默认的 FrameBuffer。</li><li><code>renderQueues</code>：渲染列队，用于控制物体渲染顺序。 <ul><li><code>isTransparent</code>：标记渲染列队是否为半透明；</li><li><code>sortMode</code>：包括以下两种：<br><code>FRONT_TO_BACK</code>：从前向后排序；<br><code>BACK_TO_FRONT</code>：从后向前排序。</li><li><code>stages</code>：指定渲染列队渲染材质中的哪些 pass，应指定为 pass 中的 phase。</li><li><code>sortRenderQueue()</code>：对渲染列队排序；</li><li><code>executeCommandBuffer</code> (view: RenderView)：执行渲染指令。</li></ul></li></ul>',9),o=[n];function c(t,a,p,s,u,R){return d(),i("div",null,o)}const h=e(l,[["render",c]]);export{m as __pageData,h as default};
