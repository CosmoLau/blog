import{_ as s,c as a,o as i,a4 as e}from"./chunks/framework.uQk9_EO2.js";const g=JSON.parse('{"title":"Built-in Surface Shader Guide","description":"","frontmatter":{},"headers":[],"relativePath":"en/shader/surface-shader/builtin-surface-shader.md","filePath":"en/shader/surface-shader/builtin-surface-shader.md","lastUpdated":1712305443000}'),n={name:"en/shader/surface-shader/builtin-surface-shader.md"},t=e(`<h1 id="built-in-surface-shader-guide" tabindex="-1">Built-in Surface Shader Guide <a class="header-anchor" href="#built-in-surface-shader-guide" aria-label="Permalink to &quot;Built-in Surface Shader Guide&quot;">​</a></h1><p>Starting from Cocos Creator 3.7.2, the <code>builtin-standard.effect</code> uses the Surface Shader architecture for implementation.</p><p>This article uses the <code>builtin-standard.effect</code> as a typical case to explain the details of Surface Shader.</p><p>You can learn about the structure, syntax and rendering process of Surface Shaders.</p><p>The following content is recommended to be read in combination with internal/effects/builtin-standard.effect.</p><h2 id="basic-structure" tabindex="-1">Basic Structure <a class="header-anchor" href="#basic-structure" aria-label="Permalink to &quot;Basic Structure&quot;">​</a></h2><p>The Surface Shader code usually consists of several parts.</p><ul><li><code>CCEffect</code>: Describes the techniques, passes, render states, and vertex attributes used in the shader.</li><li><code>Shared UBOs</code>: Defines uniforms that are needed by both vs and fs together for easy access.</li><li><code>Macro Remapping</code>: Maps some internal macros so that they can be displayed on the material panel.</li><li><code>Surface Functions</code>: Used to declare Surface functions related to Surface Shading.</li><li><code>Shader Assembly</code>: Used to assemble the code modules for each vs and fs.</li></ul><p>For more details, please visit <a href="./surface-shader-structure">Surface Shader Structure</a>.</p><h2 id="cceffect" tabindex="-1">CCEffect <a class="header-anchor" href="#cceffect" aria-label="Permalink to &quot;CCEffect&quot;">​</a></h2><p>To render an object onto the screen, the following information is needed.</p><ul><li>Model data(vertices, UV, normals, etc.)</li><li>Lighting data</li><li>Rotation, translation, scale in world space.</li><li>Render passes</li><li>Render states</li><li>Textures</li><li>Uniforms</li><li>Shader code</li></ul><p>Among them, model data, lighting information, and world space information are independent of the material, while texture, uniform, rendering state, shader code, and render process are part of the material information.</p><p><code>CCEffect</code> describes the above material-related information, and together with the engine rendering pipeline, completes the rendering process of a model.</p><h3 id="technique" tabindex="-1">technique <a class="header-anchor" href="#technique" aria-label="Permalink to &quot;technique&quot;">​</a></h3><p>The built-in Surface Shader implements two rendering techniques, <code>opaque</code> and <code>transparent</code>. The former is used for rendering non-transparent objects, and the latter is used for rendering semi-transparent objects.</p><h3 id="pass" tabindex="-1">pass <a class="header-anchor" href="#pass" aria-label="Permalink to &quot;pass&quot;">​</a></h3><p>Each technique of the built-in Surface Shader has only one pass, all of which are in PBR.</p><p>Ignoring other details, we can see the outline of a Surface Shader as follows.</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>CCEffect %{</span></span>
<span class="line"><span>  techniques:</span></span>
<span class="line"><span>  - name: opaque</span></span>
<span class="line"><span>    passes:</span></span>
<span class="line"><span>    - vert: standard-vs</span></span>
<span class="line"><span>      frag: standard-fs</span></span>
<span class="line"><span>      properties: &amp;props</span></span>
<span class="line"><span>        ...</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  - name: transparent</span></span>
<span class="line"><span>    passes:</span></span>
<span class="line"><span>    - vert: standard-vs</span></span>
<span class="line"><span>      frag: standard-fs</span></span>
<span class="line"><span>      ...</span></span>
<span class="line"><span>      properties: *props</span></span>
<span class="line"><span>}%</span></span></code></pre></div><h3 id="shader-entry-vert-and-frag" tabindex="-1">Shader Entry(vert and frag) <a class="header-anchor" href="#shader-entry-vert-and-frag" aria-label="Permalink to &quot;Shader Entry(vert and frag)&quot;">​</a></h3><p>The <code>opaque</code> and <code>transparent</code> techniques are completely identical in terms of shader code, the only difference is in the render states.</p><p>You can see that they use the same vert and frag entries.</p><div class="language-glsl vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">glsl</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> vert: standard</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">vs</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  frag: standard</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">fs</span></span></code></pre></div><h3 id="properties" tabindex="-1">properties <a class="header-anchor" href="#properties" aria-label="Permalink to &quot;properties&quot;">​</a></h3><p>Since <code>opaque</code> and <code>transparent</code> are completely identical in terms of shader code, the properties involved are the same.</p><p>All properties used in the render process are placed in the properties section. For syntax about properties, you can check <a href="./../pass-parameter-list">Optional Pass Parameters</a></p><h3 id="section-reuse" tabindex="-1">Section Reuse <a class="header-anchor" href="#section-reuse" aria-label="Permalink to &quot;Section Reuse&quot;">​</a></h3><p>In the properties section, you can see that the <code>properties</code> of <code>opaque</code> is defined as <code>properties: &amp;props</code>, while the <code>properties</code> of <code>transparent</code> is defined as <code>properties: *props</code>。</p><p>This is a reuse mechanism of sections in <code>CCEffect</code>.</p><p><code>properties: &amp;props</code> means to name the current <code>properties</code> as <code>props</code>.</p><p><code>properties: *props</code> means to use the <code>properties</code> named <code>props</code> as default value.</p><p>The result of the above configuration is: the <code>transparent</code> directly uses the <code>properties</code> of <code>opaque</code>.</p><h3 id="phase" tabindex="-1">phase <a class="header-anchor" href="#phase" aria-label="Permalink to &quot;phase&quot;">​</a></h3><p>By default, Surface Shader participates in the scene rendering stage. But there are also some special stages, such as shadows, reflection probe baking, etc.</p><p>For such requirements, we can add specific passes and mark the phase to achieve the purpose.</p><p>When the Cocos Creator executes rendering, it will get the pass of the corresponding phase in the material for rendering. If there is none, it means that this object does not participate in this phase.</p><p>In Surface Shader is shown as follows.</p><ul><li>forward-add: Used for the additional lighting phase, when the object is affected by lights other than the main light, this will be called.</li><li>shadow-caster: Used for the shadow map rendering phase.</li><li>reflect-map: Used for reflection probe baking</li></ul><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">forward</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">add</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    vert</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: standard</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">vs</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    frag</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: standard</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">fs</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    phase</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: forward</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">add</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    ...</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">shadow</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">caster</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    vert</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: shadow</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">caster</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">vs</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    frag</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: shadow</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">caster</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">fs</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    phase</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: shadow</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">caster</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    ...</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">reflect</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">map</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    vert</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: standard</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">vs</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    frag</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: reflect</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">map</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">fs</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    phase</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: reflect</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">map</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    ...</span></span></code></pre></div><p>As shown in the code above, the <code>phase</code> property is used to mark the participating phase of this pass. And <code>&amp;forward-add</code>, <code>&amp;shadow-caster</code>, <code>&amp;reflect-map</code> are names given to this pass, making it easy for subsequent techniques to reuse.</p><p>For example, the <code>transparent</code> directly reuses the <code>forward-add</code> and the <code>shadow-caster</code> passes from <code>opaque</code>.</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: transparent</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    passes</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    -</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> vert</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: standard</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">vs</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        frag</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: standard</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">fs</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        ...</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        properties</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">props</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    -</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">forward</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">add</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    -</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">shadow</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">caster</span></span></code></pre></div><h3 id="render-state" tabindex="-1">Render State <a class="header-anchor" href="#render-state" aria-label="Permalink to &quot;Render State&quot;">​</a></h3><p>As mentioned at the beginning. To complete the rendering of a model, not only define the rendering process and the required properties but also need to be combined the render state.</p><p>Render state mainly involves stencil test, depth test, rasterizer state, transparent blending, etc.</p><p>The same rendering process, properties, and shader code combined with different render states, can achieve different effects.</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">depthStencilState</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    depthFunc</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: equal</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    depthTest</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    depthWrite</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">false</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">blendState</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    targets</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    -</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> blend</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        blendSrc</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: one</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        blendDst</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: one</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        blendSrcAlpha</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: zero</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        blendDstAlpha</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: one</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">rasterizerState</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    cullMode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: front</span></span></code></pre></div><p>Render states have a set of default values, and modifications can be made when necessary.</p><p>For example, <code>opaque</code> and <code>transparent</code> only differ in render states.</p><h3 id="embedded-macros" tabindex="-1">Embedded Macros <a class="header-anchor" href="#embedded-macros" aria-label="Permalink to &quot;Embedded Macros&quot;">​</a></h3><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    embeddedMacros</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: { </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">CC_FORCE_FORWARD_SHADING</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span></code></pre></div><p>Sometimes, we want to enable or disable some macros for a specific pass. You can use the <code>embeddedMacros</code> section to do this.</p><h2 id="includes" tabindex="-1">includes <a class="header-anchor" href="#includes" aria-label="Permalink to &quot;includes&quot;">​</a></h2><p>Surface Shader provides two mechanisms for code block references: header files and CCProgram. For details, please see <a href="./includes">include</a>.</p><h2 id="shared-ubo" tabindex="-1">Shared UBO <a class="header-anchor" href="#shared-ubo" aria-label="Permalink to &quot;Shared UBO&quot;">​</a></h2><p>Many constants are used by both vs and fs or are needed by multiple techniques and passes. Defining them together for easy access.</p><p>Shared UBOs are essentially part of the Shader code, written in GLSL.</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">CCProgram shared</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ubos </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">%</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  uniform Constants {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    vec4 tilingOffset;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    vec4 albedo;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    vec4 albedoScaleAndCutoff;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    vec4 pbrParams;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    vec4 emissive;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    vec4 emissiveScaleParam;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    vec4 anisotropyParam;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  };</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">%</span></span></code></pre></div><p>In the subsequent assembly process, you only need to add a single line <code>#include &lt;shared-ubos&gt;</code> to use.</p><h2 id="macro-remapping" tabindex="-1">Macro Remapping <a class="header-anchor" href="#macro-remapping" aria-label="Permalink to &quot;Macro Remapping&quot;">​</a></h2><p>For more details about macro remapping, please refer to <a href="./macro-remapping">Macro Definition and Remapping</a>。</p><p>In the built-in Surface Shader, the <code>CCProgram macro-remapping</code> segment is used to organize all the macro-remapping stuff, which makes it easier to manage.</p><p>As can be seen, in the built-in Surface Shader, <code>#pragma define-meta</code> is used to redirect many built-in macros to the panel.</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">CCProgram macro</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">remapping </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">%</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // ui displayed macros</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  #pragma define</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">meta </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">HAS_SECOND_UV</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  #pragma define</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">meta </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">USE_TWOSIDE</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  #pragma define</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">meta </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">IS_ANISOTROPY</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  #pragma define</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">meta </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">USE_VERTEX_COLOR</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  #define </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">CC_SURFACES_USE_SECOND_UV</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> HAS_SECOND_UV</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  #define </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">CC_SURFACES_USE_TWO_SIDED</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> USE_TWOSIDE</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  #define </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">CC_SURFACES_LIGHTING_ANISOTROPIC</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> IS_ANISOTROPY</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  #define </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">CC_SURFACES_USE_VERTEX_COLOR</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> USE_VERTEX_COLOR</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // depend on UI macros</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">#</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">if</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> IS_ANISOTROPY</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ||</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> USE_NORMAL_MAP</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  #define </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">CC_SURFACES_USE_TANGENT_SPACE</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">#endif</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // functionality for each effect</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  #define </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 31</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">%</span></span></code></pre></div><h2 id="surface-functions" tabindex="-1">Surface Functions <a class="header-anchor" href="#surface-functions" aria-label="Permalink to &quot;Surface Functions&quot;">​</a></h2><p>In Surface Shader, two CCProgram sections are defined to handle the specific shader code.</p><ul><li>CCProgram surface-vertex: Used for handling vs-related calculations.</li><li>CCProgram surface-fragment: Used for handling fs-related calculations.</li></ul><h3 id="ccprogram-surface-vertex" tabindex="-1">CCProgram surface-vertex <a class="header-anchor" href="#ccprogram-surface-vertex" aria-label="Permalink to &quot;CCProgram surface-vertex&quot;">​</a></h3><p>The built-in vs process can basically meet the requirements of Surface Shader, which makes surface-vertex very simple and clean.</p><p>We take the processing of the second UV as an example.</p><p>It first defines the <code>CC_SURFACES_VERTEX_MODIFY_UV</code> macro and then implements the <code>SurfacesVertexModifyUV</code> method.</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">#define </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">CC_SURFACES_VERTEX_MODIFY_UV</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> SurfacesVertexModifyUV</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(inout SurfacesStandardVertexIntermediate In)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    In.texCoord </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> In.texCoord </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> tilingOffset.xy </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> tilingOffset.zw;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    #</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">if</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> CC_SURFACES_USE_SECOND_UV</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    In.texCoord1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> In.texCoord1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> tilingOffset.xy </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> tilingOffset.zw;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    #endif</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>This is the core mechanism of Surface Shader, which can rewrite internal functions through macro definitions, and meet specific rendering requirements without modifying the internal source code of the shader framework.</p><p>For more details, please refer to <a href="./function-replace">Function Replacement Using Macros</a> and <a href="./surface-function">Surface Shader Built-in Replaceable Functions</a>。</p><h3 id="ccprogram-surface-fragment" tabindex="-1">CCProgram surface-fragment <a class="header-anchor" href="#ccprogram-surface-fragment" aria-label="Permalink to &quot;CCProgram surface-fragment&quot;">​</a></h3><p><code>surface-fragment</code> mainly implements the filling of surface information needed for PBR calculation.</p><h4 id="macro-switch" tabindex="-1">Macro Switch <a class="header-anchor" href="#macro-switch" aria-label="Permalink to &quot;Macro Switch&quot;">​</a></h4><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">#</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">if</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> USE_ALBEDO_MAP</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    uniform sampler2D albedoMap;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    #pragma define</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">meta </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">ALBEDO_UV</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> options</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">([v_uv, v_uv1])</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">#endif</span></span></code></pre></div><p>We can see, in the built-in Surface Shader, all textures are wrapped by macro definitions. The advantage of this is that you can turn off the corresponding macros as needed to improve performance.</p><h4 id="macros-selectable-on-the-material-panel" tabindex="-1">Macros selectable on the Material Panel <a class="header-anchor" href="#macros-selectable-on-the-material-panel" aria-label="Permalink to &quot;Macros selectable on the Material Panel&quot;">​</a></h4><p><code>#pragma define-meta</code> + name + <code>options([item0,item1,....])</code> can define a macro for users to choose.</p><p>Take the following code as an example.</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">#pragma define</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">meta </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">ALBEDO_UV</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> options</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">([v_uv, v_uv1])</span></span></code></pre></div><p>On the material panel, ALBEDO_UV will appear as a drop-down selection box. When the Shader compiles, it will be based on the user&#39;s selected value.</p><p>For example, if the user selects <code>v_uv1</code>, the generated final code is as below.</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">#define </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">ALBEDO_UV</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> v_uv1</span></span></code></pre></div><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">#</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">if</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> USE_ALPHA_TEST</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    #pragma define</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">meta </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">ALPHA_TEST_CHANNEL</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> options</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">([a, r])</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">#endif</span></span></code></pre></div><p>The same applies to ALPHA_TEST_CHANNEL. By default, the &#39;a&#39; channel is used, but the &#39;r&#39; channel can also be an option.</p><h4 id="pbr-channels" tabindex="-1">PBR Channels <a class="header-anchor" href="#pbr-channels" aria-label="Permalink to &quot;PBR Channels&quot;">​</a></h4><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">#pragma define </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">OCCLUSION_CHANNEL</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">          r</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">#pragma define </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">ROUGHNESS_CHANNEL</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">          g</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">#pragma define </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">METALLIC_CHANNEL</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">           b</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">#pragma define </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">SPECULAR_INTENSITY_CHANNEL</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a</span></span></code></pre></div><p>Surface Shader uses a texture as a PBR map, and according to the definition, we can know the meaning of each channel.</p><ul><li>r: Ambient Occlusion</li><li>r: Roughness</li><li>b: Metallic</li><li>a: Specular Intensity</li></ul><h4 id="implementation" tabindex="-1">Implementation <a class="header-anchor" href="#implementation" aria-label="Permalink to &quot;Implementation&quot;">​</a></h4><p>Like the surface-vertex, the surface-fragment also uses the function replacement mechanism to implement PBR parameter filling.</p><p>For more details, please refer to the following pages:</p><ul><li><a href="./function-replace">Function Replacement Using Macros</a></li><li><a href="./surface-function">Surface Shader Built-in Replaceable Functions</a></li><li><a href="./shader-code-flow">Surface Shader Execution Flow</a></li></ul><h2 id="shader-assembly" tabindex="-1">Shader Assembly <a class="header-anchor" href="#shader-assembly" aria-label="Permalink to &quot;Shader Assembly&quot;">​</a></h2><p>The several CCPrograms mentioned above are listed as follows:</p><ul><li>shared-ubos</li><li>macro-remapping</li><li>surface-vertex</li><li>surface-fragment</li></ul><p>These are just some necessary components to implement the Surface Shader. To implement a complete Surface Shader, these parts need to be assembled in combination with other modules of the Surface Shader.</p><p>For the specific assembly mechanism, please refer to <a href="./shader-assembly">Surface Shader Assembly</a>。</p><p>The assembled CCProgram is the content referenced by the CCEffect</p><ul><li>CCProgram standard-vs</li><li>CCProgram shadow-caster-vs</li><li>CCProgram standard-fs</li><li>CCProgram shadow-caster-fs</li><li>CCProgram reflect-map-fs</li></ul>`,104),h=[t];function l(p,r,d,k,o,c){return i(),a("div",null,h)}const u=s(n,[["render",l]]);export{g as __pageData,u as default};
