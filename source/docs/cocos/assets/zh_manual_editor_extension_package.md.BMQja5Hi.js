import{_ as e,a}from"./chunks/extension-message-mgr-panel._QGWBV7V.js";import{_ as r,c as t,o,a5 as n}from"./chunks/framework.CqnjdYks.js";const s="/docs/cocos/assets/electron-process.BCBwnEOS.png",k=JSON.parse('{"title":"基础结构","description":"","frontmatter":{},"headers":[],"relativePath":"zh/manual/editor/extension/package.md","filePath":"zh/manual/editor/extension/package.md"}'),c={name:"zh/manual/editor/extension/package.md"},l=n('<h1 id="基础结构" tabindex="-1">基础结构 <a class="header-anchor" href="#基础结构" aria-label="Permalink to &quot;基础结构&quot;">​</a></h1><p>在编写扩展之前，我们首先需要了解一下 Cocos Creator 内，扩展的基础结构。</p><h2 id="electron" tabindex="-1">Electron <a class="header-anchor" href="#electron" aria-label="Permalink to &quot;Electron&quot;">​</a></h2><p>Cocos Creator 编辑器是基于 GitHub 的 <a href="https://github.com/atom/electron" target="_blank" rel="noreferrer">Electron</a> 内核开发。</p><p>Electron 是一个集成了 <a href="https://nodejs.org/" target="_blank" rel="noreferrer">Node.js</a> 和 <a href="https://github.com/chromium/chromium" target="_blank" rel="noreferrer">Google Chromium</a> 的跨平台开发框架。</p><h2 id="多进程机制" tabindex="-1">多进程机制 <a class="header-anchor" href="#多进程机制" aria-label="Permalink to &quot;多进程机制&quot;">​</a></h2><p>在 Electron 的架构中，一份应用程序由主进程和渲染进程组成，其主进程负责管理平台相关的调度，如窗口的开启关闭、菜单选项、基础对话框等等。而每一个新开启的窗口就是一个独立的渲染进程。每个进程独立享有自己的 JavaScript 内容，且彼此之间无法直接访问。当需要在进程之间传递数据时，需要使用进程间通信（IPC）机制。</p><p>相关功能可以通过阅读 <a href="https://github.com/atom/electron/blob/master/docs/tutorial/quick-start.md" target="_blank" rel="noreferrer">Electron&#39;s introduction document</a> 更深入的理解 Electron 中的主进程和渲染进程的关系。</p><p>简单点说，Electron 的主进程相当于一个 Node.js 服务端程序，而每一个窗口（渲染进程）则相当于一份客户端网页程序。</p><p>Cocos Creator 编辑器沿用了 Electron 的主进程和渲染进程的结构设计。所以扩展在编辑器内启动并运行的时候，扩展定义的 main 其实是在主进程启动，而 panels 定义的面板，则在渲染进程启动。进程结构简要概括如下：</p><p><img src="'+s+'" alt="electron-process"></p><h2 id="进程间通信" tabindex="-1">进程间通信 <a class="header-anchor" href="#进程间通信" aria-label="Permalink to &quot;进程间通信&quot;">​</a></h2><p>进程间通信实际上就是在一个进程中发消息，然后在另外一个进程中监听消息的过程。</p><p>Electron 提供了进程间通信对应的模块 <code>ipcMain</code> 和 <code>ipcRenderer</code> 来帮助我们完成这个任务。</p><p>由于这两个模块仅完成了非常基本的通信功能，并不能满足编辑器，扩展面板与主进程之间的通信需求，所以 Cocos Creator 在这之上又进行了封装，扩展了进程间消息收发的方法，方便扩展开发者和编辑器开发者制作更多复杂情景。更多说明请查看文档 <a href="./messages.html">消息系统</a>。</p><h2 id="扩展的能力" tabindex="-1">扩展的能力 <a class="header-anchor" href="#扩展的能力" aria-label="Permalink to &quot;扩展的能力&quot;">​</a></h2><p>扩展内拥有完整的 Node.js 环境，可以很方便的使用 npm 市场上大量的工具，用于完成自己想要的功能。</p><p>如果需要和其他功能交互，则需要对应功能开放对应的操作消息，我们在自己的扩展内，通过 <a href="./messages.html">消息系统</a> 触发、查询和处理编辑器内的功能或者数据。</p><p>已经开放的消息列表可以在顶部菜单 <strong>开发者 -&gt; 消息列表</strong> 面板里查看，如下图所示：</p><p><img src="'+e+'" alt="extension-message-mgr-menu"></p><p><img src="'+a+'" alt="extension-message-mgr-panel"></p>',21),i=[l];function p(h,m,d,_,u,g){return o(),t("div",null,i)}const x=r(c,[["render",p]]);export{k as __pageData,x as default};
