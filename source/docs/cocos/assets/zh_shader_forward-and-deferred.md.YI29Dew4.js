import{_ as a,c as e,o as r,a4 as t}from"./chunks/framework.uQk9_EO2.js";const p=JSON.parse('{"title":"前向渲染与延迟渲染 Shader 执行流程","description":"","frontmatter":{},"headers":[],"relativePath":"zh/shader/forward-and-deferred.md","filePath":"zh/shader/forward-and-deferred.md","lastUpdated":1712305443000}'),d={name:"zh/shader/forward-and-deferred.md"},o=t('<h1 id="前向渲染与延迟渲染-shader-执行流程" tabindex="-1">前向渲染与延迟渲染 Shader 执行流程 <a class="header-anchor" href="#前向渲染与延迟渲染-shader-执行流程" aria-label="Permalink to &quot;前向渲染与延迟渲染 Shader 执行流程&quot;">​</a></h1><p>Cocos Creator 引擎支持 前向渲染和延迟渲染。因此，在 Shader 架构上，也要为这两种渲染流程做兼容，并且让用户感知不到。</p><p>内置的 Legacy Shader 都是 PBR 材质，它们在渲染时都遵守以下流程：</p><h2 id="前向渲染" tabindex="-1">前向渲染 <a class="header-anchor" href="#前向渲染" aria-label="Permalink to &quot;前向渲染&quot;">​</a></h2><ol><li>调用 vs</li><li>调用 fs -&gt; surf -&gt; 光照计算</li></ol><h2 id="延迟渲染" tabindex="-1">延迟渲染 <a class="header-anchor" href="#延迟渲染" aria-label="Permalink to &quot;延迟渲染&quot;">​</a></h2><h3 id="buffer-阶段" tabindex="-1">Buffer 阶段 <a class="header-anchor" href="#buffer-阶段" aria-label="Permalink to &quot;Buffer 阶段&quot;">​</a></h3><ol><li>调用 vs</li><li>调用 fs -&gt; surf -&gt; GBuffer</li></ol><h3 id="lighting-阶段" tabindex="-1">Lighting 阶段 <a class="header-anchor" href="#lighting-阶段" aria-label="Permalink to &quot;Lighting 阶段&quot;">​</a></h3><ol><li>从 GBuffer 还原 StandardSurface 信息</li><li>光照计算</li></ol><p>可以看出，对于 PBR 材质来说，不管是前向渲染还是延迟渲染，用户能够控制的只有 vs 和 surf 函数。</p><p>这就统一了架构，使用户写的 Shader 可以不用修改就运行在 前向渲染管线 和 延迟渲染管线中。</p>',12),i=[o];function l(h,s,n,f,c,_){return r(),e("div",null,i)}const g=a(d,[["render",l]]);export{p as __pageData,g as default};
