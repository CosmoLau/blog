import{_ as s,c as i,o as n,a5 as a}from"./chunks/framework.CqnjdYks.js";const t="/docs/cocos/assets/setting.B3Tyki02.png",l="/docs/cocos/assets/forward-pipeline.BSTlu_M3.png",e="/docs/cocos/assets/DeferredPipeline.iriRiqkK.png",o="/docs/cocos/assets/BloomEnable.cB0XyFHC.png",u=JSON.parse('{"title":"内置渲染管线","description":"","frontmatter":{},"headers":[],"relativePath":"zh/manual/render-pipeline/builtin-pipeline.md","filePath":"zh/manual/render-pipeline/builtin-pipeline.md"}'),p={name:"zh/manual/render-pipeline/builtin-pipeline.md"},r=a('<h1 id="内置渲染管线" tabindex="-1">内置渲染管线 <a class="header-anchor" href="#内置渲染管线" aria-label="Permalink to &quot;内置渲染管线&quot;">​</a></h1><p>Cocos Creator 3.1 的内置渲染管线包括 <strong>builtin-forward</strong>（前向渲染管线）和 <strong>builtin-deferred</strong>（延迟渲染管线）。渲染管线可通过编辑器主菜单中的 <strong>项目 -&gt; 项目设置 -&gt; 项目数据 -&gt; 渲染管线</strong> 进行设置，设置完成之后 <strong>重启编辑器</strong> 即可生效。</p><p><img src="'+t+'" alt="setting"></p><h2 id="前向渲染管线" tabindex="-1">前向渲染管线 <a class="header-anchor" href="#前向渲染管线" aria-label="Permalink to &quot;前向渲染管线&quot;">​</a></h2><p>引擎默认使用 <strong>前向渲染管线</strong>，前向渲染管线的执行流程如下图所示：</p><img src="'+l+'" width="760" height="296"><p>前向渲染主要包括 <strong>ShadowFlow</strong> 和 <strong>ForwardFlow</strong> 两个阶段：</p><ul><li><strong>ShadowFlow</strong> 中包含一个 <strong>ShadowStage</strong> 会预先对场景中需要投射阴影的物体进行阴影贴图的绘制。</li><li><strong>ForwardFlow</strong> 包含一个 <strong>ForwardStage</strong>，会对场景中所有物体按照 <strong>非透明 -&gt; 光照 -&gt; 透明 -&gt; UI</strong> 的顺序依次进行绘制。在计算光照时，每个物体都会与所有光照进行计算确定是否照射到该物体，照射到该物体的光照将会执行绘制并进行光照计算，目前场景中只支持一个平行光，可接受的最大光照数量为 16。</li></ul><h2 id="延迟渲染管线" tabindex="-1">延迟渲染管线 <a class="header-anchor" href="#延迟渲染管线" aria-label="Permalink to &quot;延迟渲染管线&quot;">​</a></h2><p>目前引擎提供了试验版本的内置 <strong>延迟渲染管线</strong>，对于光照数量比较多的项目可以使用 <strong>延迟渲染管线</strong> 来缓解光照计算的压力。延迟管线的执行流程如下图所示：</p><img src="'+e+'" width="760" height="350"><p>内置的延迟渲染管线主要包括 <strong>ShadowFlow</strong> 和 <strong>MainFlow</strong> 两个过程：</p><ol><li><p><strong>ShadowFlow</strong> 与前向渲染一致，用于预先进行阴影贴图的绘制。</p></li><li><p><strong>MainFlow</strong> 包含了 <strong>GBufferStage</strong>、<strong>LightingStage</strong>、<strong>BloomStage</strong> 和 <strong>PostProcessStage</strong> 四个阶段：</p><ul><li><strong>GbufferStage</strong> 会对场景中的非透明物体进行绘制；</li><li>然后 <strong>LightingStage</strong> 会对输出到 <strong>GBuffer</strong> 中的非透明物体信息进行基于屏幕空间的光照计算，再绘制半透明物体。如果有非透明物体并且设备支持 ComputeShader，还会进行 SSPR 的资源收集与绘制；</li><li>若还开启了 Bloom 效果，<strong>BloomStage</strong> 会对已经经过 <strong>LightingStage</strong> 处理后的图像进行 Bloom 后处理；</li><li>最后 <strong>PostProcessStage</strong> 会把 <strong>BloomStage</strong>/<strong>LightingStage</strong> 输出的全屏图像绘制到主屏幕中，再进行 UI 的绘制。</li></ul></li></ol><p>开启 Bloom 有以下两种方式：</p><ol><li><p>点击 Creator 顶部菜单栏中的 <strong>项目 -&gt; 项目设置 -&gt; Macro Configurations</strong>，然后勾选 <strong>ENABLE_BLOOM</strong> 即可开启：</p><img src="'+o+`" width="760" height="510"></li><li><p>通过代码开启，示例如下：</p></li></ol><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ccclass</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;BloomSwitch&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> BloomSwitch</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> extends</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Component</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">    bloomEnabled</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> boolean</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    setupPipeline</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        (director.root?.pipeline </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">as</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> DeferredPipeline</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">).bloomEnabled </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.bloomEnabled;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    switchEnable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">toggle</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Toggle</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (toggle.isChecked </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!==</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.bloomEnabled) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">            this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.bloomEnabled </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> toggle.isChecked;</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">            this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setupPipeline</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>延迟渲染管线依赖 GPU 的 <strong>Multiple Render Targets</strong> 特性用于绘制 <strong>GBuffer</strong>，目前大部分移动平台应该都支持。WebGL1.0 环境下可以使用 <strong>WEBGL_draw_buffers</strong> 扩展支持，不过部分 WebGL1.0 平台可能不支持该扩展，那么就不能使用延迟渲染管线。</p><p>另外延迟渲染管线对于 <strong>卡通材质</strong> 无法正常进行绘制，比如引擎内置的 <code>builtin-toon</code> 材质。</p><p>引擎内置的渲染管线后续也会不断优化性能，并添加新的特性，为开发者提供更加多元和丰富的渲染特性。</p>`,19),h=[r];function g(k,d,E,c,F,y){return n(),i("div",null,h)}const _=s(p,[["render",g]]);export{u as __pageData,_ as default};
