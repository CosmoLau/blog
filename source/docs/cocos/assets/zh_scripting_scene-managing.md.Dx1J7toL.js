import{_ as s,c as i,o as a,a4 as e}from"./chunks/framework.uQk9_EO2.js";const g=JSON.parse('{"title":"加载和切换场景","description":"","frontmatter":{},"headers":[],"relativePath":"zh/scripting/scene-managing.md","filePath":"zh/scripting/scene-managing.md","lastUpdated":1712305443000}'),t={name:"zh/scripting/scene-managing.md"},n=e(`<h1 id="加载和切换场景" tabindex="-1">加载和切换场景 <a class="header-anchor" href="#加载和切换场景" aria-label="Permalink to &quot;加载和切换场景&quot;">​</a></h1><p>在 Cocos Creator 中，我们使用场景文件名（不包含扩展名）来索引指代场景。并通过以下接口进行加载和切换操作：</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">director.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">loadScene</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;MyScene&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div><p>除此之外，从 v2.4 开始 Asset Bundle 还增加了一种新的加载方式：</p><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">bundle.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">loadScene</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;MyScene&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">err</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">scene</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    director.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">runScene</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(scene);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre></div><p>Asset Bundle 提供的 <code>loadScene</code> 只会加载指定 bundle 中的场景，并不会自动运行场景，还需要使用 <code>director.runScene</code> 来运行场景。<br><code>loadScene</code> 还提供了更多参数来控制加载流程，开发者可以自行控制加载参数或者在加载完场景后做一些处理。</p><p>更多关于加载 Asset Bundle 中的场景，可参考文档 <a href="./../asset/bundle">Asset Bundle</a>。</p><h2 id="通过常驻节点进行场景资源管理和参数传递" tabindex="-1">通过常驻节点进行场景资源管理和参数传递 <a class="header-anchor" href="#通过常驻节点进行场景资源管理和参数传递" aria-label="Permalink to &quot;通过常驻节点进行场景资源管理和参数传递&quot;">​</a></h2><p>引擎同时只会运行一个场景，当切换场景时，默认会将场景内所有节点和其他实例销毁。如果我们需要用一个组件控制所有场景的加载，或在场景之间传递参数数据，就需要将该组件所在节点标记为「常驻节点」，使它在场景切换时不被自动销毁，常驻内存。我们使用以下接口：</p><p><code>director.addPersistRootNode(myNode);</code></p><p>上面的接口会将 <code>myNode</code> 变为常驻节点，这样挂在上面的组件都可以在场景之间持续作用，我们可以用这样的方法来储存玩家信息，或下一个场景初始化时需要的各种数据。 需要注意的是，目标节点必须为位于层级的根节点，否则设置无效。</p><p>如果要取消一个节点的常驻属性：</p><p><code>director.removePersistRootNode(myNode);</code></p><p>需要注意的是上面的 API 并不会立即销毁指定节点，只是将节点还原为可在场景切换时销毁的节点。</p><h2 id="场景加载回调" tabindex="-1">场景加载回调 <a class="header-anchor" href="#场景加载回调" aria-label="Permalink to &quot;场景加载回调&quot;">​</a></h2><p>加载场景时，可以附加一个参数用来指定场景加载后的回调函数：</p><p><code>director.loadScene(&quot;MyScene&quot;, onSceneLaunched);</code></p><p>上一行里 <code>onSceneLaunched</code> 就是声明在本脚本中的一个回调函数，在场景加载后可以用来进一步的进行初始化或数据传递的操作。</p><p>由于回调函数只能写在本脚本中，所以场景加载回调通常用来配合常驻节点，在常驻节点上挂载的脚本中使用。</p><h2 id="预加载场景" tabindex="-1">预加载场景 <a class="header-anchor" href="#预加载场景" aria-label="Permalink to &quot;预加载场景&quot;">​</a></h2><p><code>director.loadScene</code> 会在加载场景之后自动切换运行新场景，有些时候我们需要在后台静默加载新场景，并在加载完成后手动进行切换。那就可以预先使用 <code>preloadScene</code> 接口对场景进行预加载：</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">director.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">preloadScene</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;table&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Next scene preloaded&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre></div><p>之后在合适的时间调用 <code>loadScene</code>，就可以真正切换场景。</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">director.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">loadScene</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;table&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div><p>就算预加载还没完成，你也可以直接调用 <code>director.loadScene</code>，预加载完成后场景就会启动。</p>`,25),p=[n];function h(l,d,o,c,k,r){return a(),i("div",null,p)}const u=s(t,[["render",h]]);export{g as __pageData,u as default};
